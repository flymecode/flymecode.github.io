<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白君的博客</title>
  
  <subtitle>凡事必先骑上虎背</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-11T03:57:20.807Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ma Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK动态代理内部实现</title>
    <link href="http://yoursite.com/2019/09/09/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/09/09/JDK动态代理内部实现/</id>
    <published>2019-09-09T10:04:43.000Z</published>
    <updated>2019-10-11T03:57:20.807Z</updated>
    
    <content type="html"><![CDATA[<p>// TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;// TODO&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://yoursite.com/2019/09/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://yoursite.com/2019/09/05/HTTP状态码/</id>
    <published>2019-09-05T09:46:39.000Z</published>
    <updated>2019-09-11T23:37:23.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li><li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li><li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP-状态码&quot;&gt;&lt;a href=&quot;#HTTP-状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP 状态码&quot;&gt;&lt;/a&gt;HTTP 状态码&lt;/h2&gt;&lt;p&gt;服务器返回的 &lt;strong&gt;响应报文&lt;/strong&gt; 中第一行为状态行，包含了状态码以及
      
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB与MyISAM的区别</title>
    <link href="http://yoursite.com/2019/09/02/InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/09/02/InnoDB与MyISAM的区别/</id>
    <published>2019-09-02T08:29:48.000Z</published>
    <updated>2019-09-11T23:37:23.137Z</updated>
    
    <content type="html"><![CDATA[<ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>MyISAM 可以被压缩后进行查询操作</li><li>MyISAM 支持表级锁，InnoDB支持表，行锁。</li><li>InnoDB 不支持全文索引，而 MyISAM 支持全文索引，5.7 以后InnoDB 支持全文索引。</li><li>InnoDB 必须有主键，MyISAM 可以没有。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； &lt;/li&gt;
&lt;li&gt;InnoDB支持外键，而MyISAM不支持。对一个
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>字典</title>
    <link href="http://yoursite.com/2019/09/02/%E5%AD%97%E5%85%B8/"/>
    <id>http://yoursite.com/2019/09/02/字典/</id>
    <published>2019-09-02T05:15:15.000Z</published>
    <updated>2019-09-11T23:37:23.302Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis</strong>的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">  <span class="comment">// 哈希表数组</span></span><br><span class="line">  dictEntry **table;</span><br><span class="line">  <span class="comment">// 哈希表大小</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">  <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">  <span class="comment">// 总是等于size-1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">  <span class="comment">// 哈希表已经有的节点数量</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;的字典使用&lt;strong&gt;哈希表&lt;/strong&gt;作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。&lt;/p&gt;
&lt;h3 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka消费者</title>
    <link href="http://yoursite.com/2019/08/31/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://yoursite.com/2019/08/31/Kafka消费者/</id>
    <published>2019-08-31T09:43:56.000Z</published>
    <updated>2019-09-11T23:37:23.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消费者和消费者群组"><a href="#消费者和消费者群组" class="headerlink" title="消费者和消费者群组"></a>消费者和消费者群组</h3><p><strong>Kafka</strong> 消费者从属于消费者群组。一个群组里的消费者订阅的是同一个主题，每个消费者 接收主题一部分分区的消息。</p><p>假设主题 T1 有 4 个分区，我们创建了消费者 C1，它是群组 G1 里唯一的消费者，我们用 它订阅主题 T1。消费者 C1 将收到主题 T1 全部 4 个分区的消息，如图 4-1 所示</p><p><img src="/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174741523.png" alt="image-20190831174741523"></p><p>如果在群组 G1 里新增一个消费者 C2，那么每个消费者将分别从两个分区接收消息。我们 假设消费者 C1 接收分区 0 和分区 2 的消息，消费者 C2 接收分区 1 和分区 3 的消息，如图 4-2 所示。</p><p><img src="/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174807588.png" alt="image-20190831174807588"></p><p>如果群组 G1 有 4 个消费者，那么每个消费者可以分配到一个分区，如图 4-3 所示。</p><p><img src="/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174829692.png" alt="image-20190831174829692"></p><p>如果我们往群组里添加更多的消费者，超过主题的分区数量，那么有一部分消费者就会被 闲置，不会接收到任何消息，如图 4-4 所示。</p><p><img src="/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174853617.png" alt="image-20190831174853617"></p><p>往群组里增加消费者是横向伸缩消费能力的主要方式。</p><blockquote><p>不要让消费者的数 量超过主题分区的数量，多余的消费者只会被闲置。一个分区只能由同一个消费组内一个消费者消费。</p></blockquote><p>除了通过增加消费者来横向伸缩单个应用程序外，还经常出现多个应用程序从同一个主题 读取数据的情况。</p><p>在上面的例子里，如果新增一个只包含一个消费者的群组 G2，那么这个消费者将从主题 T1 上接收所有的消息，与群组 G1 之间互不影响。群组 G2 可以增加更多的消费者，每个 消费者可以消费若干个分区，就像群组 G1 那样，如图 4-5 所示。总的来说，群组 G2 还是 会接收到所有消息，不管有没有其他群组存在。</p><p><img src="/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831175858358.png" alt="image-20190831175858358"></p><h3 id="消费者群组和分区再均衡"><a href="#消费者群组和分区再均衡" class="headerlink" title="消费者群组和分区再均衡"></a>消费者群组和分区再均衡</h3><p>分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为<strong>再均衡</strong>。</p><p>在再均衡期间，消费者无法读取消 息，造成整个群组一小段时间的不可用。</p><p>它有可能还需要去刷新缓存，在它重新恢复状态之前会拖慢 应用程序。</p><p>消费者通过向被指派为<strong>群组协调器</strong>的 broker（不同的群组可以有不同的协调器）发送心跳 来维持它们和群组的从属关系以及它们对分区的所有权关系。</p><p>消费者会在轮询消息 （为了获取消息）或提交偏移量时发送心跳。如果消费者停止发送心跳的时间足够长，会 话就会过期，群组协调器认为它已经死亡，就会触发一次再均衡。</p><h4 id="分配分区是怎样的一个过程"><a href="#分配分区是怎样的一个过程" class="headerlink" title="分配分区是怎样的一个过程"></a>分配分区是怎样的一个过程</h4><p>当消费者要加入群组时，它会向群组协调器发送一个 JoinGroup 请求。第一 个加入群组的消费者将成为“群主”。群主从协调器那里获得群组的成员列 表（列表中包含了所有最近发送过心跳的消费者，它们被认为是活跃的）， 并负责给每一个消费者分配分区。它使用一个实现了 PartitionAssignor 接 口的类来决定哪些分区应该被分配给哪个消费者。 Kafka 内置了两种分配策略，在后面的配置参数小节我们将深入讨论。分配 完毕之后，群主把分配情况列表发送给群组协调器，协调器再把这些信息发 送给所有消费者。每个消费者只能看到自己的分配信息，只有群主知道群组 里所有消费者的分配信息。这个过程会在每次再均衡时重复发生。</p><h3 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h3><p>每次调用 poll() 方法，它总是返回由生产者写入 Kafka 但还没有被消费者读取过的记录， 我们因此可以追踪到哪些记录是被群组里的哪个消费者读取的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;消费者和消费者群组&quot;&gt;&lt;a href=&quot;#消费者和消费者群组&quot; class=&quot;headerlink&quot; title=&quot;消费者和消费者群组&quot;&gt;&lt;/a&gt;消费者和消费者群组&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Kafka&lt;/strong&gt; 消费者从属于消费者群组。一个群组里的消
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka概述</title>
    <link href="http://yoursite.com/2019/08/31/Kafka%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/08/31/Kafka概述/</id>
    <published>2019-08-31T07:15:19.000Z</published>
    <updated>2019-09-11T23:37:23.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Kafka</strong> 是一款基于发布订阅的消息系统。一般被称为 <strong>分布式消息提交日志</strong>，或者 <strong>分布式流平台</strong>。文件系统或数据库提交日志用来提供所有食物的持久记录，通过重放这些日志可以重建系统的状态。Kafka 的数据是按照<strong>一定的顺序持久化保存</strong>的，可以按需读取。</p><h3 id="消息和批次"><a href="#消息和批次" class="headerlink" title="消息和批次"></a>消息和批次</h3><p><strong>Kafka</strong> 的数据单元被称为<strong>消息</strong>。</p><p><strong>消息</strong>由字节数组组成，所以 对于 <strong>Kafka</strong> 来说，消息里的数据没有特别的格式或含义。消息可以有一个可选的元数据， 也就是<strong>键</strong>。键也是一个<strong>字节数组</strong>，与消息一样，对于 Kafka 来说也没有特殊的含义。当消 息以一种可控的方式写入不同的分区时，会用到键。最简单的例子就是为键生成一个一致 性散列值，然后使用散列值对主题分区数进行取模，为消息选取分区。这样可以保证具有 相同键的消息总是被写到相同的分区上。</p><p>为了提高效率，<strong>消息被分批次写入 Kafka</strong>。批次就是一组消息，这些消息属于同一个<strong>主题和分区</strong>。如果每一个消息都单独穿行于网络，会导致大量的网络开销，把消息分成批次传 输可以减少网络开销。不过，这要在时间延迟和吞吐量之间作出权衡：批次越大，单位时 间内处理的消息就越多，单个消息的传输时间就越长。批次数据会被压缩，这样可以提升 数据的传输和存储能力，但要做更多的计算处理。</p><h3 id="主题和分区"><a href="#主题和分区" class="headerlink" title="主题和分区"></a>主题和分区</h3><p>Kafka 的消息通过主题进行分类。<strong>主题</strong>就好比<strong>数据库的表</strong>，或者文件系统里的文件夹。主题可以被分为若干个分区，一个分区就是一个提交日志。消息以<strong>追加的方式写入分区</strong>，然 后以先入先出的顺序读取。要注意，由于一个主题一般包含几个分区，因此无法在整个主 题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序。</p><p><img src="/2019/08/31/Kafka概述/Users/maxu/blog/source/_posts/Kafka概述/image-20190831153254776.png" alt="image-20190831153254776"></p><p>图 1-5 所示的主题有 4 个分区，消息被追加写入每个分区的尾部。Kafka 通过分区来实现数据冗余和伸缩性。分区可以分布在不同的服务器上，也就是说，一个主题可以横跨多个服务器，以此来提供比单个服务器更强大的性能。</p><blockquote><p>我们通常会使用流这个词来描述 Kafka 这类系统的数据。很多时候，人们把一个主题的数 据看成一个流，不管它有多少个分区。流是一组从生产者移动到消费者的数据。</p></blockquote><h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p><strong>Kafka</strong> 的客户端就是 Kafka 系统的用户，它们被分为两种基本类型：<strong>生产者和消费者。</strong></p><p><strong>生产者</strong>创建消息。在其他发布与订阅系统中，生产者可能被称为发布者或写入者。一般情 况下，一个消息会被发布到一个特定的主题上。生产者在默认情况下把消息均衡地分布到 主题的所有分区上，而并不关心特定消息会被写到哪个分区。不过，在某些情况下，生产 者会把消息直接写到指定的分区。这通常是通过消息键和分区器来实现的，分区器为键生 成一个散列值，并将其映射到指定的分区上。这样可以保证包含同一个键的消息会被写到 同一个分区上。生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到分 区。</p><p><strong>消费者</strong>读取消息。在其他发布与订阅系统中，消费者可能被称为订阅者或读者。<strong>消费者订阅一个或多个主题</strong>，并按照消息生成的顺序读取它们。消费者通过检查消息的偏移量来区 分已经读取过的消息。<strong>偏移量</strong>是另一种元数据，它是一个不断递增的整数值，在创建消息 时，Kafka 会把它添加到消息里。在给定的分区里，每个消息的偏移量都是<strong>唯一</strong>的。消费 者把每个分区最后读取的消息偏移量保存在 Zookeeper 或 Kafka 上，如果消费者关闭或重 启，它的读取状态不会丢失。</p><p>消费者是消费者群组的一部分，也就是说，会有一个或多个消费者共同读取一个主题。群 组保证每个分区只能被一个消费者使用。如果一个消费者失效，群组 里的其他消费者可以接管失效消费者的工作。</p><p><img src="/2019/08/31/Kafka概述/Users/maxu/blog/source/_posts/Kafka概述/image-20190831154148369.png" alt="image-20190831154148369"></p><h3 id="broker和集群"><a href="#broker和集群" class="headerlink" title="broker和集群"></a>broker和集群</h3><p><strong>一个独立的 Kafka 服务器被称为 broker。</strong>broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。根据特定的硬件及其性能特征，单个 broker 可以轻松处理数 千个分区以及每秒百万级的消息量。 broker 是集群的组成部分。每个集群都有一个 broker 同时充当了集群控制器的角色（自动 从集群的活跃成员中选举出来）。控制器负责管理工作，包括将分区分配给 broker 和监控 broker。<strong>在集群中，一个分区从属于一个 broker，该 broker 被称为分区的首领</strong>。<strong>一个分区 可以分配给多个 broker，这个时候会发生分区复制</strong>（见图 1-7）。<strong>这种复制机制为分区提供 了消息冗余，如果有一个 broker 失效，其他 broker 可以接管领导权</strong>。不过，相关的消费者 和生产者都要重新连接到新的首领。</p><p><img src="/2019/08/31/Kafka概述/Users/maxu/blog/source/_posts/Kafka概述/image-20190831154752072.png" alt="image-20190831154752072"></p><p><strong>保留消息</strong>（在一定期限内）是 Kafka 的一个重要特性。Kafka broker 默认的消息保留策略 是这样的：要么保留一段时间（比如 7 天），要么保留到消息达到一定大小的字节数（比 如 1GB）。当消息数量达到这些上限时，旧消息就会过期并被删除，所以在任何时刻，可 用消息的总量都不会超过配置参数所指定的大小。</p><h3 id="为什么选择Kafka"><a href="#为什么选择Kafka" class="headerlink" title="为什么选择Kafka"></a>为什么选择Kafka</h3><ul><li>多个生产者</li><li>多个消费者</li><li>基于磁盘的数据存储</li><li>伸缩性</li><li>高性能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Kafka&lt;/strong&gt; 是一款基于发布订阅的消息系统。一般被称为 &lt;strong&gt;分布式消息提交日志&lt;/strong&gt;，或者 &lt;strong&gt;分布式流平台&lt;/strong&gt;。文件系统或数据库提交日志用来提供所有食物的持久记录，通过重放这些日志可以重建系
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="http://yoursite.com/2019/08/30/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/30/抽象类和接口的区别/</id>
    <published>2019-08-30T09:07:28.000Z</published>
    <updated>2019-09-11T23:37:23.321Z</updated>
    
    <content type="html"><![CDATA[<p>含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。</p><p>含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。</p><p>abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。</p><p>如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p><p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。</p><p>接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p><a id="more"></a><p><strong>语法区别：</strong></p><p>1.抽象类可以有构造方法，接口中不能有构造方法。</p><p>2.抽象类中可以有普通成员变量，接口中没有普通成员变量</p><p>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p><p>4.抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p><ol start="5"><li>抽象类中可以包含静态方法，接口中不能包含静态方法（JDK1.8中可以用default实现）</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ol><p><strong>下面接着再说说两者在应用上的区别：</strong></p><p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException    </span>&#123;</span><br><span class="line">    <span class="comment">//记录访问日志</span></span><br><span class="line">    <span class="comment">//进行权限判断</span></span><br><span class="line">      <span class="keyword">if</span>(具有权限)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          doService(request,response);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Excetpion e)&#123;</span><br><span class="line">          <span class="comment">// 记录异常信息</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet1</span> <span class="keyword">extends</span> <span class="title">BaseServlet</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException</span>&#123;</span><br><span class="line">   <span class="comment">//本Servlet只处理的具体业务逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。&lt;/p&gt;
&lt;p&gt;含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。&lt;/p&gt;
&lt;p&gt;abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。&lt;/p&gt;
&lt;p&gt;如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。&lt;/p&gt;
&lt;p&gt;接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。&lt;/p&gt;
&lt;p&gt;接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>字符串在JVM存储位置</title>
    <link href="http://yoursite.com/2019/08/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8JVM%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/08/30/字符串在JVM存储位置/</id>
    <published>2019-08-30T06:28:36.000Z</published>
    <updated>2019-09-11T23:37:23.317Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 概述</strong></p><p>字符串在 JVM 中如何存放？大多数人能顺利的给出如下答案：</p><p>字符串对象在JVM中可能有两个存放的位置：字符串常量池或堆内存。</p><ul><li>使用常量字符串初始化的字符串对象，它的值存放在字符串常量池中；</li><li>使用字符串构造方法创建的字符串对象，它的值存放在堆内存中；</li></ul><p>String提供了一个API, java.lang.String.intern()，这个API可以手动将一个字符串对象的值转移到字符串常量池中</p><p>在1.7之前，字符串常量池是在PermGen区域，这个区域的大小是固定的，不能在运行时根据需要扩大，也不能被垃圾收集器回收，因此如果程序中有太多的字符串调用了intern方法的话，就可能造成OOM。</p><p>在1.7以后，字符串常量池移到了堆内存中，并且可以被垃圾收集器回收，这个改动降低了字符串常量池OOM的风险。</p><a id="more"></a><p><strong>2. 案例分析</strong></p><p><img src="/2019/08/30/字符串在JVM存储位置/Users/maxu/blog/source/_posts/字符串在JVM存储位置/image-20190830145808264.png" alt="image-20190830145808264"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"max"</span>;</span><br><span class="line">String s2 = <span class="string">"max"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"max"</span>);</span><br><span class="line">s1 == s2 <span class="comment">// true</span></span><br><span class="line">s1 == s3 <span class="comment">// false</span></span><br><span class="line">String s4 = s3.intern();</span><br><span class="line">s1 == s4 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>3. intern源码分析</strong></p><p>我们来看intern方法的实现，intern方法的底层是一个native方法，在Hotspot JVM里字符串常量池它的逻辑在注释里写得很清楚：</p><p>如果常量池中有这个字符串常量，就直接返回，否则将该字符串对象的值存入常量池，再返回。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">    * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">    * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">    * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">    * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">    * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">    * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">    *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><p>在Java应用恰当得使用String.intern()方法有助于节省内存空间，但是在使用的时候，也需要注意，因为StringTable的大小是固定的，如果常量池中的字符串过多，会影响程序运行效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1. 概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串在 JVM 中如何存放？大多数人能顺利的给出如下答案：&lt;/p&gt;
&lt;p&gt;字符串对象在JVM中可能有两个存放的位置：字符串常量池或堆内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用常量字符串初始化的字符串对象，它的值存放在字符串常量池中；&lt;/li&gt;
&lt;li&gt;使用字符串构造方法创建的字符串对象，它的值存放在堆内存中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;String提供了一个API, java.lang.String.intern()，这个API可以手动将一个字符串对象的值转移到字符串常量池中&lt;/p&gt;
&lt;p&gt;在1.7之前，字符串常量池是在PermGen区域，这个区域的大小是固定的，不能在运行时根据需要扩大，也不能被垃圾收集器回收，因此如果程序中有太多的字符串调用了intern方法的话，就可能造成OOM。&lt;/p&gt;
&lt;p&gt;在1.7以后，字符串常量池移到了堆内存中，并且可以被垃圾收集器回收，这个改动降低了字符串常量池OOM的风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制过程</title>
    <link href="http://yoursite.com/2019/08/29/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/29/Redis主从复制过程/</id>
    <published>2019-08-29T10:54:06.000Z</published>
    <updated>2019-09-11T23:37:23.173Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis防止Sql注入</title>
    <link href="http://yoursite.com/2019/08/29/Mybatis%E9%98%B2%E6%AD%A2Sql%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/08/29/Mybatis防止Sql注入/</id>
    <published>2019-08-29T10:52:34.000Z</published>
    <updated>2019-09-11T23:37:23.173Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatsi 使用 <strong># </strong>防止 SQL 注入，它将所有传入的参数当作一个字符串来处理，<strong>$</strong> 则将传入的参数拼接到 SQL 上执行，一般用于表名和字段名的参数，<strong>$</strong> 所对应的参数应该由服务端提供，前端可以用参数选择，避免 SQL 注入的风险。</p><blockquote><p>额外我们还可以通过使用存储过程防止 SQL 注入</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>为什么 <strong>#</strong> 可以防止 SQL 注入呢？让我们追踪一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassDao</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 # 和 $ 符号区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id  主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from $&#123;tableName&#125; where class_id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function">ClassInfo <span class="title">getByTableNameAndId</span><span class="params">(@Param(<span class="string">"tableName"</span>)</span> String tableName,@<span class="title">Param</span><span class="params">(<span class="string">"id"</span>)</span>Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol><li>Mybatis 执行 入口是 DefaultSqlSession.selectOne(）方法。我们Debug 启动 testMybatis（）方法，并在 DefaultSqlSession.selectOne()添加断点，一行行执行Mybatis 代码：</li></ol><p><img src="/2019/08/29/Mybatis防止Sql注入/Users/maxu/blog/source/_posts/Mybatis防止Sql注入/image-20190829202052565.png" alt="image-20190829202052565"></p><ol start="2"><li>一步步向下走，当走到代码： org.apache.ibatis.executor.statement.PreparedStatementHandler#query方法时，可以看到 PreparedStatement 相信大家对这个应该不会陌生，预编译Sql并通过占位符的方式放置参数，现在 我们对比一下我们在 Dao 中的 sql ： select * from ${tableName} where class_id = #{id}</li></ol><p><img src="/2019/08/29/Mybatis防止Sql注入/Users/maxu/blog/source/_posts/Mybatis防止Sql注入/image-20190829202206705.png" alt="image-20190829202206705"></p><ol start="3"><li>如图所示，我们会发现， Mybatis 已经将 sql中 ${tableName} 替换成了 tb_class ，#{id} 也已经变成了 占位符 ？，生成了 Sql ： select * from tb_class where class_id = ?。这已经是一目了然了，Mybaitis 封装了JDBC ,执行时会将我们注解 或 Mapper 中的 Sql 和参数进行处理，并交给 PreparedStatement 来执行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mybatsi 使用 &lt;strong&gt;# &lt;/strong&gt;防止 SQL 注入，它将所有传入的参数当作一个字符串来处理，&lt;strong&gt;$&lt;/strong&gt; 则将传入的参数拼接到 SQL 上执行，一般用于表名和字段名的参数，&lt;strong&gt;$&lt;/strong&gt; 所对应的参数
      
    
    </summary>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>$与#</title>
    <link href="http://yoursite.com/2019/08/29/%E4%B8%8E/"/>
    <id>http://yoursite.com/2019/08/29/与/</id>
    <published>2019-08-29T10:51:51.000Z</published>
    <updated>2019-09-11T23:37:23.301Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统内存管理</title>
    <link href="http://yoursite.com/2019/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/29/操作系统内存管理/</id>
    <published>2019-08-29T10:51:15.000Z</published>
    <updated>2019-09-11T23:37:23.320Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程与操作系统线程的关系</title>
    <link href="http://yoursite.com/2019/08/29/Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/08/29/Java线程与操作系统线程的关系/</id>
    <published>2019-08-28T16:02:13.000Z</published>
    <updated>2019-09-11T23:37:23.140Z</updated>
    
    <content type="html"><![CDATA[<p>Linux从内核2.6开始使用NPTL （Native POSIX Thread Library）支持，但这时线程本质上还轻量级进程。 </p><p>　　Java里的线程是由JVM来管理的，它如何对应到操作系统的线程是由JVM的实现来确定的。Linux 2.6上的HotSpot使用了NPTL机制，<strong>JVM线程跟内核轻量级进程有一一对应的关系</strong>。线程的调度完全交给了操作系统内核，当然jvm还保留一些策略足以影响到其内部的线程调度，举个例子，在linux下，只要一个Thread.run就会调用一个fork产生一个线程。</p><p>　　Java线程在Windows及Linux平台上的实现方式，现在看来，是内核线程的实现方式。<strong>这种方式实现的线程，是直接由操作系统内核支持的——由内核完成线程切换，内核通过操纵调度器（Thread Scheduler）实现线程调度，并将线程任务反映到各个处理器上。</strong>内核线程是内核的一个分身。程序一般不直接使用该内核线程，而是使用其高级接口，即轻量级进程（LWP），也即线程。这看起来可能很拗口。看图：</p><p><img src="/2019/08/29/Java线程与操作系统线程的关系/image-20190829000505977.png" alt="image-20190829000505977"></p><p>说明：KLT即内核线程Kernel Thread，是“内核分身”。每一个KLT对应到进程P中的某一个轻量级进程LWP（也即线程），期间要经过用户态、内核态的切换，并在Thread Scheduler 下反应到处理器CPU上。）</p><p>这种线程实现的方式也有它的缺陷：在程序面上使用内核线程，必然在操作系统上多次来回切换用户态及内核态；另外，因为是一对一的线程模型，LWP的支持数是有限的。</p><p>　　对于一个大型程序，我们可以<strong>开辟的线程数量至少等于运行机器的cpu内核数量</strong>。java程序里我们可以通过下面的一行代码得到这个数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><p>所以最小线程数量即时cpu内核数量。如果所有的任务都是计算密集型的，这个最小线程数量就是我们需要的线程数。开辟更多的线程只会影响程序的性能，因为线程之间的切换工作，会消耗额外的资源。如果任务是IO密集型的任务，我们可以开辟更多的线程执行任务。当一个任务执行IO操作的时候，线程将会被阻塞，处理器立刻会切换到另外一个合适的线程去执行。如果我们只拥有与内核数量一样多的线程，即使我们有任务要执行，他们也不能执行，因为处理器没有可以用来调度的线程。</p><p>​       <strong>如果线程有50%的时间被阻塞，线程的数量就应该是内核数量的2倍。</strong>如果更少的比例被阻塞，那么它们就是计算密集型的，则需要开辟较少的线程。如果有更多的时间被阻塞，那么就是IO密集型的程序，则可以开辟更多的线程。于是我们可以得到下面的线程数量计算公式：线程数量=内核数量 / （1 - 阻塞率）</p><p>　　我们可以通过相应的分析工具或者java的management包来得到阻塞率的数值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux从内核2.6开始使用NPTL （Native POSIX Thread Library）支持，但这时线程本质上还轻量级进程。 &lt;/p&gt;
&lt;p&gt;　　Java里的线程是由JVM来管理的，它如何对应到操作系统的线程是由JVM的实现来确定的。Linux 2.6上的HotS
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>orderby工作流程</title>
    <link href="http://yoursite.com/2019/08/27/orderby%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/27/orderby工作流程/</id>
    <published>2019-08-27T08:10:24.000Z</published>
    <updated>2019-09-11T23:37:23.295Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>唯一索引和普通索引</title>
    <link href="http://yoursite.com/2019/08/27/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/08/27/唯一索引和普通索引/</id>
    <published>2019-08-27T07:41:38.000Z</published>
    <updated>2019-09-11T23:37:23.320Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信方式</title>
    <link href="http://yoursite.com/2019/08/26/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/26/进程间通信方式/</id>
    <published>2019-08-26T04:04:51.000Z</published>
    <updated>2019-09-11T23:37:23.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间通信（IPC）介绍"><a href="#进程间通信（IPC）介绍" class="headerlink" title="进程间通信（IPC）介绍"></a>进程间通信（IPC）介绍</h1><p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。</p><p>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p><p>以Linux中的C语言编程为例。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>它是半双工的，具有固定的读端和写端。</li><li>它只能用于具有<strong>亲缘关系</strong>的进程之间的通信（也是父子进程或者兄弟进程之间）。</li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;    <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。如下图：</p><p><img src="/2019/08/26/进程间通信方式/image-20190826141126633.png" alt="image-20190826141126633"></p><p>要关闭管道只需将这两个文件描述符关闭即可。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p><p><img src="/2019/08/26/进程间通信方式/Users/maxu/hexo/source/_posts/进程间通信方式/image-20190826141404697.png" alt="image-20190826141404697"></p><p>Fork 之后的半双工管道</p><p><img src="/2019/08/26/进程间通信方式/Users/maxu/hexo/source/_posts/进程间通信方式/image-20190826141436913.png" alt="image-20190826141436913"></p><p>从父进程到子进程的管道</p><p>若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程间通信（IPC）介绍&quot;&gt;&lt;a href=&quot;#进程间通信（IPC）介绍&quot; class=&quot;headerlink&quot; title=&quot;进程间通信（IPC）介绍&quot;&gt;&lt;/a&gt;进程间通信（IPC）介绍&lt;/h1&gt;&lt;p&gt;进程间通信（IPC，InterProcess Communi
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis缓存</title>
    <link href="http://yoursite.com/2019/08/20/Mybatis%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/08/20/Mybatis缓存/</id>
    <published>2019-08-20T08:37:26.000Z</published>
    <updated>2019-09-11T23:37:23.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。具体执行过程如下图所示。</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/image-20190820165449480.png" alt></p><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入<code>Local Cache</code>，最后返回结果给用户。具体实现类的类关系图如下图所示。</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/image-20190820170058613.png" alt="image-20190820170058613"></p><h3 id="一级缓存配置"><a href="#一级缓存配置" class="headerlink" title="一级缓存配置"></a>一级缓存配置</h3><p>我们来看看如何使用MyBatis一级缓存。开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，<code>SESSION</code>或者<code>STATEMENT</code>，默认是<code>SESSION</code>级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是<code>STATEMENT</code>级别，可以理解为缓存只对当前执行的这一个<code>Statement</code>有效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>MyBatis一级缓存的生命周期和SqlSession一致。</li><li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li><li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li></ol><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/image-20190820171955509.png" alt="image-20190820171955509"></p><p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p><p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><h3 id="二级缓存配置"><a href="#二级缓存配置" class="headerlink" title="二级缓存配置"></a>二级缓存配置</h3><p>要正确的使用二级缓存，需完成如下配置的。</p><ol><li>在MyBatis的配置文件中开启二级缓存。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在MyBatis的映射XML中配置cache或者 cache-ref 。</li></ol><p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过。</li><li><code>eviction</code>： 定义回收的策略，常见的有FIFO，LRU。</li><li><code>flushInterval</code>： 配置一定时间自动刷新缓存，单位是毫秒。</li><li><code>size</code>： 最多缓存对象的个数。</li><li><code>readOnly</code>： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</li><li><code>blocking</code>： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li></ul><p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"mapper.StudentMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li><li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li><li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一级缓存&quot;&gt;&lt;a href=&quot;#一级缓存&quot; class=&quot;headerlink&quot; title=&quot;一级缓存&quot;&gt;&lt;/a&gt;一级缓存&lt;/h2&gt;&lt;p&gt;在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部
      
    
    </summary>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://yoursite.com/2019/08/19/SpringAOP/"/>
    <id>http://yoursite.com/2019/08/19/SpringAOP/</id>
    <published>2019-08-19T06:46:18.000Z</published>
    <updated>2019-09-11T23:37:23.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h2><p>AOP称为面向切面编程，那我们怎么理解面向切面编程？</p><p>我们学Java面向对象的时候，如果代码重复了怎么办啊？可以分成下面几个步骤：</p><ul><li>抽取成方法</li><li>抽取类</li></ul><p>抽取成类的方式我们称之为：<strong>纵向抽取</strong></p><ul><li>通过继承的方式实现纵向抽取</li></ul><p>但是，我们现在的办法不行：即使抽取成类还是会出现重复的代码，因为这些逻辑(开始、结束、提交事务)<strong>依附在我们业务类的方法逻辑中</strong>！</p><a id="more"></a><p><img src="http://pw5y8kqa5.bkt.clouddn.com/image-20190819150731837.png" alt="image-20190819150731837"></p><p>现在纵向抽取的方式不行了，AOP的理念：就是将<strong>分散在各个业务逻辑代码中相同的代码通过横向切割的方式</strong>抽取到一个独立的模块中！</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/image-20190819150839531.png" alt="image-20190819150839531"></p><p>上面的图也很清晰了，将重复性的逻辑代码横切出来其实很容易(我们简单可认为就是封装成一个类就好了)，但我们要将这些<strong>被我们横切出来的逻辑代码融合到业务逻辑中</strong>，来完成和之前(没抽取前)一样的功能！这就是AOP首要解决的问题了！</p><h2 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h2><p>被我们横切出来的逻辑代码融合到业务逻辑中，来完成和之前(没抽取前)一样的功能</p><p>Spring AOP构建在动态代理基础之上，因此，<strong>Spring对AOP的支持局限于方法拦截</strong>。</p><p>在Java中动态代理有<strong>两种</strong>方式：</p><ul><li><p>JDK动态代理</p></li><li><p>CGLib动态代理</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/image-20190819151005879.png" alt="image-20190819151005879"></p></li></ul><p>JDK动态代理是需要实现某个接口了，而我们类未必全部会有接口，于是CGLib代理就有了~~</p><ul><li>CGLib代理其生成的动态代理对象是目标类的子类</li><li>Spring AOP<strong>默认是使用JDK动态代理</strong>，如果代理的类<strong>没有接口则会使用CGLib代理</strong>。</li></ul><p>那么JDK代理和CGLib代理我们该用哪个呢？？在《精通Spring4.x 企业应用开发实战》给出了建议：</p><ul><li>如果是<strong>单例的我们最好使用CGLib代理</strong>，如果是多例的我们最好使用JDK代理</li></ul><p>原因：</p><ul><li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li><li>如果是单例的代理，推荐使用CGLib</li></ul><p>看到这里我们就应该知道什么是Spring AOP(面向切面编程)了：<strong>将相同逻辑的重复代码横向抽取出来，使用动态代理技术将这些重复代码织入到目标对象方法中，实现和原来一样的功能</strong>。</p><ul><li>这样一来，我们就在<strong>写业务时只关心业务代码</strong>，而不用关心与业务无关的代码</li></ul><h2 id="AOP的术语"><a href="#AOP的术语" class="headerlink" title="AOP的术语"></a>AOP的术语</h2><p><strong>连接点</strong>(Join point)：</p><ul><li><strong>能够被拦截的地方</strong>：Spring AOP是基于动态代理的，所以是方法拦截的。每个成员方法都可以称之为连接点</li></ul><p><strong>切点</strong>(Poincut)：</p><ul><li><strong>具体定位的连接点</strong>：上面也说了，每个方法都可以称之为连接点，我们<strong>具体定位到某一个方法就成为切点</strong>。</li></ul><p><strong>增强/通知</strong>(Advice)：</p><ul><li>表示添加到切点的一段逻辑代码，并定位连接点的方位信息。<ul><li>简单来说就定义了是干什么的，具体是在哪干</li><li>Spring AOP提供了5种Advice类型给我们：前置、后置、返回、异常、环绕给我们使用！</li></ul></li></ul><p><strong>织入</strong>(Weaving)：</p><ul><li>将<code>增强/通知</code>添加到目标类的具体连接点上的过程。</li></ul><p><strong>引入/引介</strong>(Introduction)：</p><ul><li><code>引入/引介</code>允许我们<strong>向现有的类添加新方法或属性</strong>。是一种<strong>特殊</strong>的增强！</li></ul><p><strong>切面</strong>(Aspect)：</p><ul><li>切面由切点和<code>增强/通知</code>组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</li></ul><p>在《Spring 实战 (第4版)》给出的</p><p>通知/增强包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知/增强被应用的具体位置。其中关键的是切点定义了哪些连接点会得到通知/增强。</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/image-20190819152914835.png" alt="image-20190819152914835"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AOP概述&quot;&gt;&lt;a href=&quot;#AOP概述&quot; class=&quot;headerlink&quot; title=&quot;AOP概述&quot;&gt;&lt;/a&gt;AOP概述&lt;/h2&gt;&lt;p&gt;AOP称为面向切面编程，那我们怎么理解面向切面编程？&lt;/p&gt;
&lt;p&gt;我们学Java面向对象的时候，如果代码重复了怎么办啊？可以分成下面几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽取成方法&lt;/li&gt;
&lt;li&gt;抽取类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽取成类的方式我们称之为：&lt;strong&gt;纵向抽取&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过继承的方式实现纵向抽取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，我们现在的办法不行：即使抽取成类还是会出现重复的代码，因为这些逻辑(开始、结束、提交事务)&lt;strong&gt;依附在我们业务类的方法逻辑中&lt;/strong&gt;！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringIOC</title>
    <link href="http://yoursite.com/2019/08/18/SpringIOC/"/>
    <id>http://yoursite.com/2019/08/18/SpringIOC/</id>
    <published>2019-08-18T02:46:18.000Z</published>
    <updated>2019-09-11T23:37:23.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IoC(Inversion of Control)控制反转，包含了两个方面：一、控制。二、反转</p></blockquote><p>我们可以简单认为：</p><ul><li>控制指的是：<strong>当前对象对内部成员的控制权</strong>。</li><li>反转指的是：这种控制权<strong>不由当前对象管理</strong>了，由其他(类,第三方容器)来管理。</li></ul><p>使用IOC的好处：</p><ol><li>不用自己组装，拿来就用。</li><li>享受单例的好处，效率高，不浪费空间。</li><li>便于单元测试，方便切换mock组件。</li><li>便于进行AOP操作，对于使用者是透明的。</li><li>统一配置，便于修改</li></ol><a id="more"></a><h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><h3 id="IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系"><a href="#IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系" class="headerlink" title="IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系"></a>IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系</h3><ul><li>原理就是通过Java的<strong>反射技术</strong>来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！</li><li>再通过配置文件(xml)或者注解来<strong>描述</strong>类与类之间的关系</li><li>我们就可以通过这些配置信息和反射技术来<strong>构建</strong>出对应的对象和依赖关系</li></ul><h3 id="Spring-IOC容器是怎么实现对象的创建和依赖的："><a href="#Spring-IOC容器是怎么实现对象的创建和依赖的：" class="headerlink" title="Spring IOC容器是怎么实现对象的创建和依赖的："></a>Spring IOC容器是怎么实现对象的创建和依赖的：</h3><ol><li>根据Bean配置信息在容器内部创建Bean定义注册表</li><li>根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</li><li>将这些准备就绪的Bean放到Map缓存池中，等待应用程序调用</li></ol><h3 id="Spring容器-Bean工厂-可简单分成两种："><a href="#Spring容器-Bean工厂-可简单分成两种：" class="headerlink" title="Spring容器(Bean工厂)可简单分成两种："></a>Spring容器(Bean工厂)可简单分成两种：</h3><ul><li><p>BeanFactory</p></li><li><ul><li>这是最基础、面向Spring的</li></ul></li><li><p>ApplicationContext</p></li><li><ul><li>这是在BeanFactory基础之上，面向使用Spring框架的开发者。提供了一系列的功能！</li></ul></li></ul><p>几乎所有的应用场合<strong>都是</strong>使用ApplicationContext！</p><p>简要总结：</p><ul><li>BeanDefinitionReader<strong>读取Resource所指向的配置文件资源</strong>，然后解析配置文件。配置文件中每一个<code>&lt;bean&gt;</code>解析成一个<strong>BeanDefinition对象</strong>，并<strong>保存</strong>到BeanDefinitionRegistry中；</li><li>容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy<strong>进行Bean实例化的工作</strong>；使用<strong>BeanWrapper完成Bean属性的设置</strong>工作；</li><li>单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的<strong>缓存器</strong>，它是一个用HashMap实现的缓存器，单实例的Bean<strong>以beanName为键保存在这个HashMap</strong>中。</li></ul><h3 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h3><p>依赖注入的方式有3种方式：</p><ul><li><strong>属性注入</strong>–&gt;通过<code>setter()</code>方法注入</li><li>构造函数注入</li><li>工厂方法注入</li></ul><h3 id="一个接口两个实现类，怎么在调用的时候优先调用某个实现类呢？"><a href="#一个接口两个实现类，怎么在调用的时候优先调用某个实现类呢？" class="headerlink" title="一个接口两个实现类，怎么在调用的时候优先调用某个实现类呢？"></a>一个接口两个实现类，怎么在调用的时候优先调用某个实现类呢？</h3><ul><li><p>使用<code>@Primary</code>注解设置为<strong>首选</strong>的注入Bean</p></li><li><p>使用<code>@Qualifier</code>注解设置<strong>特定名称的Bean</strong>来限定注入！</p></li><li><ul><li>也可以使用自定义的注解来标识  </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;IoC(Inversion of Control)控制反转，包含了两个方面：一、控制。二、反转&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以简单认为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制指的是：&lt;strong&gt;当前对象对内部成员的控制权&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;反转指的是：这种控制权&lt;strong&gt;不由当前对象管理&lt;/strong&gt;了，由其他(类,第三方容器)来管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用IOC的好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不用自己组装，拿来就用。&lt;/li&gt;
&lt;li&gt;享受单例的好处，效率高，不浪费空间。&lt;/li&gt;
&lt;li&gt;便于单元测试，方便切换mock组件。&lt;/li&gt;
&lt;li&gt;便于进行AOP操作，对于使用者是透明的。&lt;/li&gt;
&lt;li&gt;统一配置，便于修改&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>LinkedListMap介绍</title>
    <link href="http://yoursite.com/2019/08/16/LinkedListMap%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/08/16/LinkedListMap介绍/</id>
    <published>2019-08-16T08:32:13.000Z</published>
    <updated>2019-09-11T23:37:23.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LinkedHashMap继承于HashMap</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>HashMap是无序的，当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      hashMap.put(<span class="string">"name5"</span>, <span class="string">"value5"</span>);</span><br><span class="line">      hashMap.put(<span class="string">"name6"</span>, <span class="string">"value6"</span>);</span><br><span class="line">      hashMap.put(<span class="string">"name7"</span>, <span class="string">"value7"</span>);</span><br><span class="line">      Set&lt;Map.Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">          Map.Entry entry = iterator.next();</span><br><span class="line">          String key = (String) entry.getKey();</span><br><span class="line">          String value = (String) entry.getValue();</span><br><span class="line">          System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key:name6,value:value6</span><br><span class="line">key:name5,value:value5</span><br><span class="line">key:name7,value:value7</span><br></pre></td></tr></table></figure><p>同样的数据，我们再试试LinkedHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">"name5"</span>, <span class="string">"value5"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"name6"</span>, <span class="string">"value6"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"name7"</span>, <span class="string">"value7"</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry = iterator.next();</span><br><span class="line">            String key = (String) entry.getKey();</span><br><span class="line">            String value = (String) entry.getValue();</span><br><span class="line">            System.out.println(<span class="string">"key:"</span> + key + <span class="string">",value:"</span> + value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key:name5,value:value5</span><br><span class="line">key:name6,value:value6</span><br><span class="line">key:name7,value:value7</span><br></pre></td></tr></table></figure><p>LinkedHashMap是有序的，且默认为插入顺序。</p><p>LinkedHashMap空参的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用HashMap的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// 这里是指是否基于访问排序，默认为false</span></span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里accessOrder设置为false，表示不是访问顺序而是插入顺序存储的，这也是默认值，表示LinkedHashMap中存储的顺序是按照调用put方法插入的顺序进行排序的。LinkedHashMap也提供了可以设置accessOrder的构造方法。</p><p>在HashMap的构造函数中，调用了init方法，而在HashMap中init方法是空实现，但LinkedHashMap重写了该方法，所以在LinkedHashMap的构造方法里，调用了自身的init方法，init的重写实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called by superclass constructors and pseudoconstructors (clone,</span></span><br><span class="line"><span class="comment">    * readObject) before any entries are inserted into the map.  Initializes</span></span><br><span class="line"><span class="comment">    * the chain.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建了一个hash=-1，key、value、next都为null的Entry</span></span><br><span class="line">       header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// 让创建的Entry的before和after都指向自身，注意after不是之前提到的next</span></span><br><span class="line">       <span class="comment">// 其实就是创建了一个只有头部节点的双向链表</span></span><br><span class="line">       header.before = header.after = header;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap有自己的静态内部类Entry，它继承了HashMap.Node，定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以LinkedHashMap构造函数，主要就是调用HashMap构造函数初始化了一个Entry[] table，然后调用自身的init初始化了一个只有头结点的双向链表。</p><p>总结</p><p>LinkedHashMap 是继承于HashMap，是基于HashMap和双向链表来实现的。</p><p>HashMap无序；LinkedHashMap有序，可分为插入顺序和访问顺序两种。如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</p><p>LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。</p><p>LinkedHashMap是线程不安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LinkedHashMap继承于HashMap&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
