<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白君的博客</title>
  
  <subtitle>凡事必先骑上虎背</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://flymecode.gitee.io/blog/"/>
  <updated>2019-10-22T13:17:09.719Z</updated>
  <id>https://flymecode.gitee.io/blog/</id>
  
  <author>
    <name>Ma Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Paxos</title>
    <link href="https://flymecode.gitee.io/blog/2019/10/22/Paxos/"/>
    <id>https://flymecode.gitee.io/blog/2019/10/22/Paxos/</id>
    <published>2019-10-22T13:13:18.000Z</published>
    <updated>2019-10-22T13:17:09.719Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，数据不是存储在单个节点中的，所以分布式系统面临数据的一致性问题，就比如 DNS 系统中，域名的更新一样。为了解决这个问题，出现了 paxos 算法，paxos 算法其实是一个共识算法。系统的最终一致性，不仅需要达成共识，还会取决于 client 的行为。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分布式系统中，数据不是存储在单个节点中的，所以分布式系统面临数据的一致性问题，就比如 DNS 系统中，域名的更新一样。为了解决这个问题，出现了 paxos 算法，paxos 算法其实是一个共识算法。系统的最终一致性，不仅需要达成共识，还会取决于 client 的行为。&lt;/
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://flymecode.gitee.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCP如何保证可靠传输</title>
    <link href="https://flymecode.gitee.io/blog/2019/10/12/TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <id>https://flymecode.gitee.io/blog/2019/10/12/TCP如何保证可靠传输/</id>
    <published>2019-10-12T09:24:13.000Z</published>
    <updated>2019-10-12T09:25:34.783Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</p></li><li><p><strong>对失序数据包重排序</strong>：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</p></li><li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据；</p></li><li><p><strong>应答机制</strong>：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p></li><li><p><strong>超时重发</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p></li><li><p><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据包校验&lt;/strong&gt;：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对失序数据包重排序&lt;/strong
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://flymecode.gitee.io/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存回收：LRU算法</title>
    <link href="https://flymecode.gitee.io/blog/2019/10/11/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%EF%BC%9ALRU%E7%AE%97%E6%B3%95/"/>
    <id>https://flymecode.gitee.io/blog/2019/10/11/Redis内存回收：LRU算法/</id>
    <published>2019-10-11T07:00:39.000Z</published>
    <updated>2019-10-11T07:12:00.479Z</updated>
    
    <content type="html"><![CDATA[<p>Redis中采用两种算法进行内存回收，<a href="http://www.cnblogs.com/WJ5888/p/4359783.html" target="_blank" rel="noopener">引用计数算法</a> 以及LRU算法，在操作系统内存管理一节中，我们都学习过LRU算法(最近最久未使用算法),那么什么是LRU算法呢</p><p>LRU算法作为内存管理的一种有效算法,其含义是在内存有限的情况下，当内存容量不足时，为了保证程序的运行，这时就不得不淘汰内存中的一些对象，释放这些对象占用的空间，那么选择淘汰哪些对象呢？LRU算法就提供了一种策略，告诉我们选择最近一段时间内，最久未使用的对象将其淘汰，至于为什么要选择最久未使用的，可以想想，最近一段时间内使用的东西，我们是不是可能一会又要用到呢~，而很长一段时间内都没有使用过的东西，也许永远都不会再使用~</p><p>在操作系统中LRU算法淘汰的不是内存中的对象，而是页,当内存中数据不足时，通过LRU算法，选择一页(一般是4KB)将其交换到虚拟内存区(Swap区)</p><a id="more"></a><p><img src="/blog/2019/10/11/Redis内存回收：LRU算法/image-20191011151041256.png" alt="image-20191011151041256"></p><p>假设前提，只有三块内存空间可以使用，每一块内存空间只能存放一个对象，如A、B、C…</p><p>1、最开始时，内存空间是空的，因此依次进入A、B、C是没有问题的</p><p>2、当加入D时，就出现了问题，内存空间不够了，因此根据LRU算法，内存空间中A待的时间最为久远，选择A,将其淘汰</p><p>3、当再次引用B时，内存空间中的B又处于活跃状态，而C则变成了内存空间中，近段时间最久未使用的</p><p>4、当再次向内存空间加入E时，这时内存空间又不足了，选择在内存空间中待的最久的C将其淘汰出内存，这时的内存空间存放的对象就是E-&gt;B-&gt;D</p><p>LRU算法的整体思路就是这样的</p><p>算法实现应该采用怎样的数据结构 </p><p>队列？那不就是FIFO算法嘛~，LRU算法最为精典的实现，就是HashMap+Double LinkedList，时间复杂度为O(1),具体可以参考相关代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis中采用两种算法进行内存回收，&lt;a href=&quot;http://www.cnblogs.com/WJ5888/p/4359783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引用计数算法&lt;/a&gt; 以及LRU算法，在操作系统内存管理一节中，我们都学习过LRU算法(最近最久未使用算法),那么什么是LRU算法呢&lt;/p&gt;
&lt;p&gt;LRU算法作为内存管理的一种有效算法,其含义是在内存有限的情况下，当内存容量不足时，为了保证程序的运行，这时就不得不淘汰内存中的一些对象，释放这些对象占用的空间，那么选择淘汰哪些对象呢？LRU算法就提供了一种策略，告诉我们选择最近一段时间内，最久未使用的对象将其淘汰，至于为什么要选择最久未使用的，可以想想，最近一段时间内使用的东西，我们是不是可能一会又要用到呢~，而很长一段时间内都没有使用过的东西，也许永远都不会再使用~&lt;/p&gt;
&lt;p&gt;在操作系统中LRU算法淘汰的不是内存中的对象，而是页,当内存中数据不足时，通过LRU算法，选择一页(一般是4KB)将其交换到虚拟内存区(Swap区)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://flymecode.gitee.io/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>异常体系</title>
    <link href="https://flymecode.gitee.io/blog/2019/10/11/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <id>https://flymecode.gitee.io/blog/2019/10/11/异常体系/</id>
    <published>2019-10-11T06:07:07.000Z</published>
    <updated>2019-10-11T06:10:00.302Z</updated>
    
    <content type="html"><![CDATA[<p><strong>异常的一些基本知识</strong></p><ul><li><strong>异常的架构</strong></li></ul><p>　　异常的继承结构：Throwable为基类，Error和Exception继承Throwable。Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。</p><p><img src="/blog/2019/10/11/异常体系/image-20191011140924190.png" alt="image-20191011140924190"></p><ul><li><strong>Error异常</strong></li></ul><p>　　Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA 虚拟机出现错误。Error是一种unchecked Exception，编译器不会检查Error是否被处理，在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。</p><ul><li><strong>RuntimeException异常</strong></li></ul><p>　　Exception异常包括RuntimeException异常和其他非RuntimeException的异常。<br>　　RuntimeException 是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出　RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。</p><ul><li><strong>Checked Exception异常</strong></li></ul><p>　　Checked Exception异常，这也是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是checked Exception，上图中的IOException和ClassNotFoundException。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;异常的一些基本知识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;异常的架构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　异常的继承结构：Throwable为基类，Error和Exception继承Throwable。Error和Runt
      
    
    </summary>
    
    
      <category term="Java" scheme="https://flymecode.gitee.io/blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理内部实现</title>
    <link href="https://flymecode.gitee.io/blog/2019/09/09/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>https://flymecode.gitee.io/blog/2019/09/09/JDK动态代理内部实现/</id>
    <published>2019-09-09T10:04:43.000Z</published>
    <updated>2019-10-11T03:57:20.807Z</updated>
    
    <content type="html"><![CDATA[<p>// TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;// TODO&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="https://flymecode.gitee.io/blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="https://flymecode.gitee.io/blog/2019/09/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://flymecode.gitee.io/blog/2019/09/05/HTTP状态码/</id>
    <published>2019-09-05T09:46:39.000Z</published>
    <updated>2019-09-11T23:37:23.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li><li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li><li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP-状态码&quot;&gt;&lt;a href=&quot;#HTTP-状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP 状态码&quot;&gt;&lt;/a&gt;HTTP 状态码&lt;/h2&gt;&lt;p&gt;服务器返回的 &lt;strong&gt;响应报文&lt;/strong&gt; 中第一行为状态行，包含了状态码以及
      
    
    </summary>
    
    
      <category term="http" scheme="https://flymecode.gitee.io/blog/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB与MyISAM的区别</title>
    <link href="https://flymecode.gitee.io/blog/2019/09/02/InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://flymecode.gitee.io/blog/2019/09/02/InnoDB与MyISAM的区别/</id>
    <published>2019-09-02T08:29:48.000Z</published>
    <updated>2019-09-11T23:37:23.137Z</updated>
    
    <content type="html"><![CDATA[<ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>MyISAM 可以被压缩后进行查询操作</li><li>MyISAM 支持表级锁，InnoDB支持表，行锁。</li><li>InnoDB 不支持全文索引，而 MyISAM 支持全文索引，5.7 以后InnoDB 支持全文索引。</li><li>InnoDB 必须有主键，MyISAM 可以没有。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； &lt;/li&gt;
&lt;li&gt;InnoDB支持外键，而MyISAM不支持。对一个
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://flymecode.gitee.io/blog/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>字典</title>
    <link href="https://flymecode.gitee.io/blog/2019/09/02/%E5%AD%97%E5%85%B8/"/>
    <id>https://flymecode.gitee.io/blog/2019/09/02/字典/</id>
    <published>2019-09-02T05:15:15.000Z</published>
    <updated>2019-09-11T23:37:23.302Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis</strong>的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">  <span class="comment">// 哈希表数组</span></span><br><span class="line">  dictEntry **table;</span><br><span class="line">  <span class="comment">// 哈希表大小</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">  <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">  <span class="comment">// 总是等于size-1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">  <span class="comment">// 哈希表已经有的节点数量</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;的字典使用&lt;strong&gt;哈希表&lt;/strong&gt;作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。&lt;/p&gt;
&lt;h3 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="redis" scheme="https://flymecode.gitee.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka消费者</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/31/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/31/Kafka消费者/</id>
    <published>2019-08-31T09:43:56.000Z</published>
    <updated>2019-09-11T23:37:23.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消费者和消费者群组"><a href="#消费者和消费者群组" class="headerlink" title="消费者和消费者群组"></a>消费者和消费者群组</h3><p><strong>Kafka</strong> 消费者从属于消费者群组。一个群组里的消费者订阅的是同一个主题，每个消费者 接收主题一部分分区的消息。</p><p>假设主题 T1 有 4 个分区，我们创建了消费者 C1，它是群组 G1 里唯一的消费者，我们用 它订阅主题 T1。消费者 C1 将收到主题 T1 全部 4 个分区的消息，如图 4-1 所示</p><p><img src="/blog/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174741523.png" alt="image-20190831174741523"></p><p>如果在群组 G1 里新增一个消费者 C2，那么每个消费者将分别从两个分区接收消息。我们 假设消费者 C1 接收分区 0 和分区 2 的消息，消费者 C2 接收分区 1 和分区 3 的消息，如图 4-2 所示。</p><p><img src="/blog/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174807588.png" alt="image-20190831174807588"></p><p>如果群组 G1 有 4 个消费者，那么每个消费者可以分配到一个分区，如图 4-3 所示。</p><p><img src="/blog/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174829692.png" alt="image-20190831174829692"></p><p>如果我们往群组里添加更多的消费者，超过主题的分区数量，那么有一部分消费者就会被 闲置，不会接收到任何消息，如图 4-4 所示。</p><p><img src="/blog/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831174853617.png" alt="image-20190831174853617"></p><p>往群组里增加消费者是横向伸缩消费能力的主要方式。</p><blockquote><p>不要让消费者的数 量超过主题分区的数量，多余的消费者只会被闲置。一个分区只能由同一个消费组内一个消费者消费。</p></blockquote><p>除了通过增加消费者来横向伸缩单个应用程序外，还经常出现多个应用程序从同一个主题 读取数据的情况。</p><p>在上面的例子里，如果新增一个只包含一个消费者的群组 G2，那么这个消费者将从主题 T1 上接收所有的消息，与群组 G1 之间互不影响。群组 G2 可以增加更多的消费者，每个 消费者可以消费若干个分区，就像群组 G1 那样，如图 4-5 所示。总的来说，群组 G2 还是 会接收到所有消息，不管有没有其他群组存在。</p><p><img src="/blog/2019/08/31/Kafka消费者/Users/maxu/blog/source/_posts/Kafka消费者/image-20190831175858358.png" alt="image-20190831175858358"></p><h3 id="消费者群组和分区再均衡"><a href="#消费者群组和分区再均衡" class="headerlink" title="消费者群组和分区再均衡"></a>消费者群组和分区再均衡</h3><p>分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为<strong>再均衡</strong>。</p><p>在再均衡期间，消费者无法读取消 息，造成整个群组一小段时间的不可用。</p><p>它有可能还需要去刷新缓存，在它重新恢复状态之前会拖慢 应用程序。</p><p>消费者通过向被指派为<strong>群组协调器</strong>的 broker（不同的群组可以有不同的协调器）发送心跳 来维持它们和群组的从属关系以及它们对分区的所有权关系。</p><p>消费者会在轮询消息 （为了获取消息）或提交偏移量时发送心跳。如果消费者停止发送心跳的时间足够长，会 话就会过期，群组协调器认为它已经死亡，就会触发一次再均衡。</p><h4 id="分配分区是怎样的一个过程"><a href="#分配分区是怎样的一个过程" class="headerlink" title="分配分区是怎样的一个过程"></a>分配分区是怎样的一个过程</h4><p>当消费者要加入群组时，它会向群组协调器发送一个 JoinGroup 请求。第一 个加入群组的消费者将成为“群主”。群主从协调器那里获得群组的成员列 表（列表中包含了所有最近发送过心跳的消费者，它们被认为是活跃的）， 并负责给每一个消费者分配分区。它使用一个实现了 PartitionAssignor 接 口的类来决定哪些分区应该被分配给哪个消费者。 Kafka 内置了两种分配策略，在后面的配置参数小节我们将深入讨论。分配 完毕之后，群主把分配情况列表发送给群组协调器，协调器再把这些信息发 送给所有消费者。每个消费者只能看到自己的分配信息，只有群主知道群组 里所有消费者的分配信息。这个过程会在每次再均衡时重复发生。</p><h3 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h3><p>每次调用 poll() 方法，它总是返回由生产者写入 Kafka 但还没有被消费者读取过的记录， 我们因此可以追踪到哪些记录是被群组里的哪个消费者读取的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;消费者和消费者群组&quot;&gt;&lt;a href=&quot;#消费者和消费者群组&quot; class=&quot;headerlink&quot; title=&quot;消费者和消费者群组&quot;&gt;&lt;/a&gt;消费者和消费者群组&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Kafka&lt;/strong&gt; 消费者从属于消费者群组。一个群组里的消
      
    
    </summary>
    
    
      <category term="Kafka" scheme="https://flymecode.gitee.io/blog/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka概述</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/31/Kafka%E6%A6%82%E8%BF%B0/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/31/Kafka概述/</id>
    <published>2019-08-31T07:15:19.000Z</published>
    <updated>2019-09-11T23:37:23.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Kafka</strong> 是一款基于发布订阅的消息系统。一般被称为 <strong>分布式消息提交日志</strong>，或者 <strong>分布式流平台</strong>。文件系统或数据库提交日志用来提供所有食物的持久记录，通过重放这些日志可以重建系统的状态。Kafka 的数据是按照<strong>一定的顺序持久化保存</strong>的，可以按需读取。</p><h3 id="消息和批次"><a href="#消息和批次" class="headerlink" title="消息和批次"></a>消息和批次</h3><p><strong>Kafka</strong> 的数据单元被称为<strong>消息</strong>。</p><p><strong>消息</strong>由字节数组组成，所以 对于 <strong>Kafka</strong> 来说，消息里的数据没有特别的格式或含义。消息可以有一个可选的元数据， 也就是<strong>键</strong>。键也是一个<strong>字节数组</strong>，与消息一样，对于 Kafka 来说也没有特殊的含义。当消 息以一种可控的方式写入不同的分区时，会用到键。最简单的例子就是为键生成一个一致 性散列值，然后使用散列值对主题分区数进行取模，为消息选取分区。这样可以保证具有 相同键的消息总是被写到相同的分区上。</p><p>为了提高效率，<strong>消息被分批次写入 Kafka</strong>。批次就是一组消息，这些消息属于同一个<strong>主题和分区</strong>。如果每一个消息都单独穿行于网络，会导致大量的网络开销，把消息分成批次传 输可以减少网络开销。不过，这要在时间延迟和吞吐量之间作出权衡：批次越大，单位时 间内处理的消息就越多，单个消息的传输时间就越长。批次数据会被压缩，这样可以提升 数据的传输和存储能力，但要做更多的计算处理。</p><h3 id="主题和分区"><a href="#主题和分区" class="headerlink" title="主题和分区"></a>主题和分区</h3><p>Kafka 的消息通过主题进行分类。<strong>主题</strong>就好比<strong>数据库的表</strong>，或者文件系统里的文件夹。主题可以被分为若干个分区，一个分区就是一个提交日志。消息以<strong>追加的方式写入分区</strong>，然 后以先入先出的顺序读取。要注意，由于一个主题一般包含几个分区，因此无法在整个主 题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序。</p><p><img src="/blog/2019/08/31/Kafka概述/Users/maxu/blog/source/_posts/Kafka概述/image-20190831153254776.png" alt="image-20190831153254776"></p><p>图 1-5 所示的主题有 4 个分区，消息被追加写入每个分区的尾部。Kafka 通过分区来实现数据冗余和伸缩性。分区可以分布在不同的服务器上，也就是说，一个主题可以横跨多个服务器，以此来提供比单个服务器更强大的性能。</p><blockquote><p>我们通常会使用流这个词来描述 Kafka 这类系统的数据。很多时候，人们把一个主题的数 据看成一个流，不管它有多少个分区。流是一组从生产者移动到消费者的数据。</p></blockquote><h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p><strong>Kafka</strong> 的客户端就是 Kafka 系统的用户，它们被分为两种基本类型：<strong>生产者和消费者。</strong></p><p><strong>生产者</strong>创建消息。在其他发布与订阅系统中，生产者可能被称为发布者或写入者。一般情 况下，一个消息会被发布到一个特定的主题上。生产者在默认情况下把消息均衡地分布到 主题的所有分区上，而并不关心特定消息会被写到哪个分区。不过，在某些情况下，生产 者会把消息直接写到指定的分区。这通常是通过消息键和分区器来实现的，分区器为键生 成一个散列值，并将其映射到指定的分区上。这样可以保证包含同一个键的消息会被写到 同一个分区上。生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到分 区。</p><p><strong>消费者</strong>读取消息。在其他发布与订阅系统中，消费者可能被称为订阅者或读者。<strong>消费者订阅一个或多个主题</strong>，并按照消息生成的顺序读取它们。消费者通过检查消息的偏移量来区 分已经读取过的消息。<strong>偏移量</strong>是另一种元数据，它是一个不断递增的整数值，在创建消息 时，Kafka 会把它添加到消息里。在给定的分区里，每个消息的偏移量都是<strong>唯一</strong>的。消费 者把每个分区最后读取的消息偏移量保存在 Zookeeper 或 Kafka 上，如果消费者关闭或重 启，它的读取状态不会丢失。</p><p>消费者是消费者群组的一部分，也就是说，会有一个或多个消费者共同读取一个主题。群 组保证每个分区只能被一个消费者使用。如果一个消费者失效，群组 里的其他消费者可以接管失效消费者的工作。</p><p><img src="/blog/2019/08/31/Kafka概述/Users/maxu/blog/source/_posts/Kafka概述/image-20190831154148369.png" alt="image-20190831154148369"></p><h3 id="broker和集群"><a href="#broker和集群" class="headerlink" title="broker和集群"></a>broker和集群</h3><p><strong>一个独立的 Kafka 服务器被称为 broker。</strong>broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。根据特定的硬件及其性能特征，单个 broker 可以轻松处理数 千个分区以及每秒百万级的消息量。 broker 是集群的组成部分。每个集群都有一个 broker 同时充当了集群控制器的角色（自动 从集群的活跃成员中选举出来）。控制器负责管理工作，包括将分区分配给 broker 和监控 broker。<strong>在集群中，一个分区从属于一个 broker，该 broker 被称为分区的首领</strong>。<strong>一个分区 可以分配给多个 broker，这个时候会发生分区复制</strong>（见图 1-7）。<strong>这种复制机制为分区提供 了消息冗余，如果有一个 broker 失效，其他 broker 可以接管领导权</strong>。不过，相关的消费者 和生产者都要重新连接到新的首领。</p><p><img src="/blog/2019/08/31/Kafka概述/Users/maxu/blog/source/_posts/Kafka概述/image-20190831154752072.png" alt="image-20190831154752072"></p><p><strong>保留消息</strong>（在一定期限内）是 Kafka 的一个重要特性。Kafka broker 默认的消息保留策略 是这样的：要么保留一段时间（比如 7 天），要么保留到消息达到一定大小的字节数（比 如 1GB）。当消息数量达到这些上限时，旧消息就会过期并被删除，所以在任何时刻，可 用消息的总量都不会超过配置参数所指定的大小。</p><h3 id="为什么选择Kafka"><a href="#为什么选择Kafka" class="headerlink" title="为什么选择Kafka"></a>为什么选择Kafka</h3><ul><li>多个生产者</li><li>多个消费者</li><li>基于磁盘的数据存储</li><li>伸缩性</li><li>高性能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Kafka&lt;/strong&gt; 是一款基于发布订阅的消息系统。一般被称为 &lt;strong&gt;分布式消息提交日志&lt;/strong&gt;，或者 &lt;strong&gt;分布式流平台&lt;/strong&gt;。文件系统或数据库提交日志用来提供所有食物的持久记录，通过重放这些日志可以重建系
      
    
    </summary>
    
    
      <category term="Kafka" scheme="https://flymecode.gitee.io/blog/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/30/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/30/抽象类和接口的区别/</id>
    <published>2019-08-30T09:07:28.000Z</published>
    <updated>2019-09-11T23:37:23.321Z</updated>
    
    <content type="html"><![CDATA[<p>含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。</p><p>含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。</p><p>abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。</p><p>如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p><p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。</p><p>接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p><a id="more"></a><p><strong>语法区别：</strong></p><p>1.抽象类可以有构造方法，接口中不能有构造方法。</p><p>2.抽象类中可以有普通成员变量，接口中没有普通成员变量</p><p>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p><p>4.抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p><ol start="5"><li>抽象类中可以包含静态方法，接口中不能包含静态方法（JDK1.8中可以用default实现）</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ol><p><strong>下面接着再说说两者在应用上的区别：</strong></p><p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException    </span>&#123;</span><br><span class="line">    <span class="comment">//记录访问日志</span></span><br><span class="line">    <span class="comment">//进行权限判断</span></span><br><span class="line">      <span class="keyword">if</span>(具有权限)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          doService(request,response);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Excetpion e)&#123;</span><br><span class="line">          <span class="comment">// 记录异常信息</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet1</span> <span class="keyword">extends</span> <span class="title">BaseServlet</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion,ServletException</span>&#123;</span><br><span class="line">   <span class="comment">//本Servlet只处理的具体业务逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。&lt;/p&gt;
&lt;p&gt;含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。&lt;/p&gt;
&lt;p&gt;abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。&lt;/p&gt;
&lt;p&gt;如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。&lt;/p&gt;
&lt;p&gt;接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。&lt;/p&gt;
&lt;p&gt;接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://flymecode.gitee.io/blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>字符串在JVM存储位置</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8JVM%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/30/字符串在JVM存储位置/</id>
    <published>2019-08-30T06:28:36.000Z</published>
    <updated>2019-09-11T23:37:23.317Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 概述</strong></p><p>字符串在 JVM 中如何存放？大多数人能顺利的给出如下答案：</p><p>字符串对象在JVM中可能有两个存放的位置：字符串常量池或堆内存。</p><ul><li>使用常量字符串初始化的字符串对象，它的值存放在字符串常量池中；</li><li>使用字符串构造方法创建的字符串对象，它的值存放在堆内存中；</li></ul><p>String提供了一个API, java.lang.String.intern()，这个API可以手动将一个字符串对象的值转移到字符串常量池中</p><p>在1.7之前，字符串常量池是在PermGen区域，这个区域的大小是固定的，不能在运行时根据需要扩大，也不能被垃圾收集器回收，因此如果程序中有太多的字符串调用了intern方法的话，就可能造成OOM。</p><p>在1.7以后，字符串常量池移到了堆内存中，并且可以被垃圾收集器回收，这个改动降低了字符串常量池OOM的风险。</p><a id="more"></a><p><strong>2. 案例分析</strong></p><p><img src="/blog/2019/08/30/字符串在JVM存储位置/Users/maxu/blog/source/_posts/字符串在JVM存储位置/image-20190830145808264.png" alt="image-20190830145808264"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"max"</span>;</span><br><span class="line">String s2 = <span class="string">"max"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"max"</span>);</span><br><span class="line">s1 == s2 <span class="comment">// true</span></span><br><span class="line">s1 == s3 <span class="comment">// false</span></span><br><span class="line">String s4 = s3.intern();</span><br><span class="line">s1 == s4 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>3. intern源码分析</strong></p><p>我们来看intern方法的实现，intern方法的底层是一个native方法，在Hotspot JVM里字符串常量池它的逻辑在注释里写得很清楚：</p><p>如果常量池中有这个字符串常量，就直接返回，否则将该字符串对象的值存入常量池，再返回。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">    * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">    * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">    * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">    * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">    * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">    * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">    * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">    * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">    *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><p>在Java应用恰当得使用String.intern()方法有助于节省内存空间，但是在使用的时候，也需要注意，因为StringTable的大小是固定的，如果常量池中的字符串过多，会影响程序运行效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1. 概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串在 JVM 中如何存放？大多数人能顺利的给出如下答案：&lt;/p&gt;
&lt;p&gt;字符串对象在JVM中可能有两个存放的位置：字符串常量池或堆内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用常量字符串初始化的字符串对象，它的值存放在字符串常量池中；&lt;/li&gt;
&lt;li&gt;使用字符串构造方法创建的字符串对象，它的值存放在堆内存中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;String提供了一个API, java.lang.String.intern()，这个API可以手动将一个字符串对象的值转移到字符串常量池中&lt;/p&gt;
&lt;p&gt;在1.7之前，字符串常量池是在PermGen区域，这个区域的大小是固定的，不能在运行时根据需要扩大，也不能被垃圾收集器回收，因此如果程序中有太多的字符串调用了intern方法的话，就可能造成OOM。&lt;/p&gt;
&lt;p&gt;在1.7以后，字符串常量池移到了堆内存中，并且可以被垃圾收集器回收，这个改动降低了字符串常量池OOM的风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://flymecode.gitee.io/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制过程</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/29/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/29/Redis主从复制过程/</id>
    <published>2019-08-29T10:54:06.000Z</published>
    <updated>2019-09-11T23:37:23.173Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis防止Sql注入</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/29/Mybatis%E9%98%B2%E6%AD%A2Sql%E6%B3%A8%E5%85%A5/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/29/Mybatis防止Sql注入/</id>
    <published>2019-08-29T10:52:34.000Z</published>
    <updated>2020-01-19T02:41:44.112Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatsi 使用 <strong># </strong>防止 SQL 注入，它将所有传入的参数当作一个字符串来处理，<strong>$</strong> 则将传入的参数拼接到 SQL 上执行，一般用于表名和字段名的参数，<strong>$</strong> 所对应的参数应该由服务端提供，前端可以用参数选择，避免 SQL 注入的风险。</p><blockquote><p>额外我们还可以通过使用存储过程防止 SQL 注入</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>为什么 <strong>#</strong> 可以防止 SQL 注入呢？让我们追踪一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassDao</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 # 和 $ 符号区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id  主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from $&#123;tableName&#125; where class_id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function">ClassInfo <span class="title">getByTableNameAndId</span><span class="params">(@Param(<span class="string">"tableName"</span>)</span> String tableName,@<span class="title">Param</span><span class="params">(<span class="string">"id"</span>)</span>Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol><li>Mybatis 执行 入口是 DefaultSqlSession.selectOne(）方法。我们Debug 启动 testMybatis（）方法，并在 DefaultSqlSession.selectOne()添加断点，一行行执行Mybatis 代码：</li></ol><p><img src="/blog/2019/08/29/Mybatis防止Sql注入/./Mybatis防止Sql注入/image-20190829202052565.png" alt="image-20190829202052565"></p><ol start="2"><li>一步步向下走，当走到代码： org.apache.ibatis.executor.statement.PreparedStatementHandler#query方法时，可以看到 PreparedStatement 相信大家对这个应该不会陌生，预编译Sql并通过占位符的方式放置参数，现在 我们对比一下我们在 Dao 中的 sql ： select * from ${tableName} where class_id = #{id}</li></ol><p><img src="/blog/2019/08/29/Mybatis防止Sql注入/./Mybatis防止Sql注入/image-20190829202206705.png" alt="image-20190829202206705"></p><ol start="3"><li>如图所示，我们会发现， Mybatis 已经将 sql中 ${tableName} 替换成了 tb_class ，#{id} 也已经变成了 占位符 ？，生成了 Sql ： select * from tb_class where class_id = ?。这已经是一目了然了，Mybaitis 封装了JDBC ,执行时会将我们注解 或 Mapper 中的 Sql 和参数进行处理，并交给 PreparedStatement 来执行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mybatsi 使用 &lt;strong&gt;# &lt;/strong&gt;防止 SQL 注入，它将所有传入的参数当作一个字符串来处理，&lt;strong&gt;$&lt;/strong&gt; 则将传入的参数拼接到 SQL 上执行，一般用于表名和字段名的参数，&lt;strong&gt;$&lt;/strong&gt; 所对应的参数
      
    
    </summary>
    
    
      <category term="Mybatis" scheme="https://flymecode.gitee.io/blog/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>$与#</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/29/%E4%B8%8E/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/29/与/</id>
    <published>2019-08-29T10:51:51.000Z</published>
    <updated>2019-09-11T23:37:23.301Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统内存管理</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/29/操作系统内存管理/</id>
    <published>2019-08-29T10:51:15.000Z</published>
    <updated>2019-09-11T23:37:23.320Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java线程与操作系统线程的关系</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/29/Java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/29/Java线程与操作系统线程的关系/</id>
    <published>2019-08-28T16:02:13.000Z</published>
    <updated>2019-09-11T23:37:23.140Z</updated>
    
    <content type="html"><![CDATA[<p>Linux从内核2.6开始使用NPTL （Native POSIX Thread Library）支持，但这时线程本质上还轻量级进程。 </p><p>　　Java里的线程是由JVM来管理的，它如何对应到操作系统的线程是由JVM的实现来确定的。Linux 2.6上的HotSpot使用了NPTL机制，<strong>JVM线程跟内核轻量级进程有一一对应的关系</strong>。线程的调度完全交给了操作系统内核，当然jvm还保留一些策略足以影响到其内部的线程调度，举个例子，在linux下，只要一个Thread.run就会调用一个fork产生一个线程。</p><p>　　Java线程在Windows及Linux平台上的实现方式，现在看来，是内核线程的实现方式。<strong>这种方式实现的线程，是直接由操作系统内核支持的——由内核完成线程切换，内核通过操纵调度器（Thread Scheduler）实现线程调度，并将线程任务反映到各个处理器上。</strong>内核线程是内核的一个分身。程序一般不直接使用该内核线程，而是使用其高级接口，即轻量级进程（LWP），也即线程。这看起来可能很拗口。看图：</p><p><img src="/blog/2019/08/29/Java线程与操作系统线程的关系/image-20190829000505977.png" alt="image-20190829000505977"></p><p>说明：KLT即内核线程Kernel Thread，是“内核分身”。每一个KLT对应到进程P中的某一个轻量级进程LWP（也即线程），期间要经过用户态、内核态的切换，并在Thread Scheduler 下反应到处理器CPU上。）</p><p>这种线程实现的方式也有它的缺陷：在程序面上使用内核线程，必然在操作系统上多次来回切换用户态及内核态；另外，因为是一对一的线程模型，LWP的支持数是有限的。</p><p>　　对于一个大型程序，我们可以<strong>开辟的线程数量至少等于运行机器的cpu内核数量</strong>。java程序里我们可以通过下面的一行代码得到这个数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><p>所以最小线程数量即时cpu内核数量。如果所有的任务都是计算密集型的，这个最小线程数量就是我们需要的线程数。开辟更多的线程只会影响程序的性能，因为线程之间的切换工作，会消耗额外的资源。如果任务是IO密集型的任务，我们可以开辟更多的线程执行任务。当一个任务执行IO操作的时候，线程将会被阻塞，处理器立刻会切换到另外一个合适的线程去执行。如果我们只拥有与内核数量一样多的线程，即使我们有任务要执行，他们也不能执行，因为处理器没有可以用来调度的线程。</p><p>​       <strong>如果线程有50%的时间被阻塞，线程的数量就应该是内核数量的2倍。</strong>如果更少的比例被阻塞，那么它们就是计算密集型的，则需要开辟较少的线程。如果有更多的时间被阻塞，那么就是IO密集型的程序，则可以开辟更多的线程。于是我们可以得到下面的线程数量计算公式：线程数量=内核数量 / （1 - 阻塞率）</p><p>　　我们可以通过相应的分析工具或者java的management包来得到阻塞率的数值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux从内核2.6开始使用NPTL （Native POSIX Thread Library）支持，但这时线程本质上还轻量级进程。 &lt;/p&gt;
&lt;p&gt;　　Java里的线程是由JVM来管理的，它如何对应到操作系统的线程是由JVM的实现来确定的。Linux 2.6上的HotS
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://flymecode.gitee.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>orderby工作流程</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/27/orderby%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/27/orderby工作流程/</id>
    <published>2019-08-27T08:10:24.000Z</published>
    <updated>2019-09-11T23:37:23.295Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="mysql" scheme="https://flymecode.gitee.io/blog/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>唯一索引和普通索引</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/27/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/27/唯一索引和普通索引/</id>
    <published>2019-08-27T07:41:38.000Z</published>
    <updated>2019-09-11T23:37:23.320Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="mysql" scheme="https://flymecode.gitee.io/blog/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信方式</title>
    <link href="https://flymecode.gitee.io/blog/2019/08/26/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://flymecode.gitee.io/blog/2019/08/26/进程间通信方式/</id>
    <published>2019-08-26T04:04:51.000Z</published>
    <updated>2020-01-19T02:42:40.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间通信（IPC）介绍"><a href="#进程间通信（IPC）介绍" class="headerlink" title="进程间通信（IPC）介绍"></a>进程间通信（IPC）介绍</h1><p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。</p><p>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p><p>以Linux中的C语言编程为例。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>它是半双工的，具有固定的读端和写端。</li><li>它只能用于具有<strong>亲缘关系</strong>的进程之间的通信（也是父子进程或者兄弟进程之间）。</li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;    <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。如下图：</p><p><img src="/blog/2019/08/26/进程间通信方式/./进程间通信方式/image-20190826141126633.png" alt="image-20190826141126633"></p><p>要关闭管道只需将这两个文件描述符关闭即可。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：</p><p><img src="/blog/2019/08/26/进程间通信方式/./进程间通信方式/image-20190826141404697.png" alt="image-20190826141404697"></p><p>Fork 之后的半双工管道</p><p><img src="/blog/2019/08/26/进程间通信方式/Users/maxu/hexo/source/_posts/进程间通信方式/image-20190826141436913.png" alt="image-20190826141436913"></p><p>从父进程到子进程的管道</p><p>若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程间通信（IPC）介绍&quot;&gt;&lt;a href=&quot;#进程间通信（IPC）介绍&quot; class=&quot;headerlink&quot; title=&quot;进程间通信（IPC）介绍&quot;&gt;&lt;/a&gt;进程间通信（IPC）介绍&lt;/h1&gt;&lt;p&gt;进程间通信（IPC，InterProcess Communi
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://flymecode.gitee.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
