<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白君的博客</title>
  
  <subtitle>凡事必先骑上虎背</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-13T12:38:13.514Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ma Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://yoursite.com/2019/08/13/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/08/13/分布式锁/</id>
    <published>2019-08-13T09:44:19.000Z</published>
    <updated>2019-08-13T12:38:13.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p><p>阻塞锁通常使用互斥量来实现：</p><ul><li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li><li>互斥量为 1 表示未锁定状态。</li></ul><p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p><a id="more"></a><h2 id="数据库的唯一索引"><a href="#数据库的唯一索引" class="headerlink" title="数据库的唯一索引"></a>数据库的唯一索引</h2><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。</p><p>存在以下几个问题：</p><ul><li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁。</li><li>只能是非阻塞锁，插入失败直接就报错了，无法重试。</li><li>不可重入，已经获得锁的进程也必须重新获取锁。</li></ul><h2 id="Redis-的-SETNX-指令"><a href="#Redis-的-SETNX-指令" class="headerlink" title="Redis 的 SETNX 指令"></a>Redis 的 SETNX 指令</h2><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p><h2 id="Redis-的-RedLock-算法"><a href="#Redis-的-RedLock-算法" class="headerlink" title="Redis 的 RedLock 算法"></a>Redis 的 RedLock 算法</h2><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p><ul><li>尝试从 N 个互相独立 Redis 实例获取锁；</li><li>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那么就认为锁获取成功了；</li><li>如果锁获取失败，就到每个实例上释放锁。</li></ul><h2 id="Zookeeper-的有序节点"><a href="#Zookeeper-的有序节点" class="headerlink" title="Zookeeper 的有序节点"></a>Zookeeper 的有序节点</h2><h3 id="1-Zookeeper-抽象模型"><a href="#1-Zookeeper-抽象模型" class="headerlink" title="1. Zookeeper 抽象模型"></a>1. Zookeeper 抽象模型</h3><p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</p><p><img src="/2019/08/13/分布式锁/WX20190813-203526@2x.png" alt></p><h3 id="2-节点类型"><a href="#2-节点类型" class="headerlink" title="2. 节点类型"></a>2. 节点类型</h3><ul><li>永久节点：不会因为会话结束或者超时而消失；</li><li>临时节点：如果会话结束或者超时就会消失；</li><li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li></ul><h3 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3. 监听器"></a>3. 监听器</h3><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p><h3 id="4-分布式锁实现"><a href="#4-分布式锁实现" class="headerlink" title="4. 分布式锁实现"></a>4. 分布式锁实现</h3><ul><li>创建一个锁目录 /lock；</li><li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li><li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li><li>执行业务代码，完成后，删除对应的子节点。</li></ul><h3 id="5-会话超时"><a href="#5-会话超时" class="headerlink" title="5. 会话超时"></a>5. 会话超时</h3><p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，Zookeeper 分布式锁不会出现数据库的唯一索引实现的分布式锁释放锁失败问题。</p><h3 id="6-羊群效应"><a href="#6-羊群效应" class="headerlink" title="6. 羊群效应"></a>6. 羊群效应</h3><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;p&gt;在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。&lt;/p&gt;
&lt;p&gt;阻塞锁通常使用互斥量来实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；&lt;/li&gt;
&lt;li&gt;互斥量为 1 表示未锁定状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>再探索引-索引优化</title>
    <link href="http://yoursite.com/2019/08/13/%E5%86%8D%E6%8E%A2%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/08/13/再探索引/</id>
    <published>2019-08-12T16:41:13.000Z</published>
    <updated>2019-08-13T08:33:33.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id, actor_ id FROM sakila.film_actor WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure><h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-独立的列&quot;&gt;&lt;a href=&quot;#1-独立的列&quot; class=&quot;headerlink&quot; title=&quot;1. 独立的列&quot;&gt;&lt;/a&gt;1. 独立的列&lt;/h3&gt;&lt;p&gt;在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。&lt;/p&gt;
&lt;p&gt;例如下面
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于CMS的Young GC</title>
    <link href="http://yoursite.com/2019/08/12/%E5%85%B3%E4%BA%8ECMS%E7%9A%84Young-GC/"/>
    <id>http://yoursite.com/2019/08/12/关于CMS的Young-GC/</id>
    <published>2019-08-12T06:16:02.000Z</published>
    <updated>2019-08-12T07:32:00.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>​    CMS 收集器是一种最短回收时间为目标的收集器。在重视服务的相应速度，希望系统停顿时间最短，以给用户最好的体验</p><p>​    CMS 收集器，实现的算法是标记-清除算法，整个过程分为：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>其中初始标记和重新标记需要 STW</p><a id="more"></a><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>​    首先初始标记阶段找出 GC Root 所能直接关联的对象，速度很快，如 Java 栈中引用的对象、方法区中静态变量应用的对象和系统词典中应用的对象并标记，找出老年代对象在 eden 区有引用关系的对象并标记，最后把这些标记的对象复制到 to，在复制过程中还要判断活跃的对象 GC 年领是否已经达到了阈值，如果已经达到阈值，就直接晋升到老年代，YGC 结束之后将 from 和 to 的引用互换。其中大对象直接晋升到老年代，避免了在 eden 区、form、to 之间的复制。在发生 YGC 前，虚拟机会检查老年代最大的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么进行 YGC 是安全的，如果不成立，检查虚拟机是允许担保失败，如果允许会检查老年代最大的连续空间是否大于历次晋升到老年代对象的平均大小或者新生代对象总大小，如果大于则进行 YGC ，如果条件不成立，或者虚拟机不允许空间担保失败，则进行一次 Full GC。</p><h2 id="CMS-收集器缺点"><a href="#CMS-收集器缺点" class="headerlink" title="CMS 收集器缺点"></a>CMS 收集器缺点</h2><ul><li>CMS 收集器对CPU 资源非常敏感</li><li>CMS 收收集器无法处理浮动垃圾，可能出现 “ Concureent Mode Failure” 失败而导致另一次 Full GC 的产生。要是 CMS 在运行期间预留的内存无法满足程序需要，就会出现一次 “ Concureent Mode Failure” ,这个时候虚拟机临时启动 Serial Old 收集器重新来进行老年代的垃圾收集，这样停顿时间就很长了。</li><li>大量空间碎片，空间碎片过多的话会给分配大对象带来麻烦，即使老年代有很大的空间但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC, 为了解决这个问题，CMS 提供了内存碎片整理的参数来设置，或者我进行几次不带碎片整理的 Full GC 之后，随后带一次碎片整理的 Full GC。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CMS-收集器&quot;&gt;&lt;a href=&quot;#CMS-收集器&quot; class=&quot;headerlink&quot; title=&quot;CMS 收集器&quot;&gt;&lt;/a&gt;CMS 收集器&lt;/h2&gt;&lt;p&gt;​    CMS 收集器是一种最短回收时间为目标的收集器。在重视服务的相应速度，希望系统停顿时间最短，以给用户最好的体验&lt;/p&gt;
&lt;p&gt;​    CMS 收集器，实现的算法是标记-清除算法，整个过程分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;重新标记&lt;/li&gt;
&lt;li&gt;并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中初始标记和重新标记需要 STW&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>threadlocal内存泄漏</title>
    <link href="http://yoursite.com/2019/07/12/threadlocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2019/07/12/threadlocal内存泄漏/</id>
    <published>2019-07-12T07:30:29.000Z</published>
    <updated>2019-08-12T08:10:59.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p><img src="/2019/07/12/threadlocal内存泄漏/F352F038-78E0-4AD0-A817-DC807B20E808.png" alt="F352F038-78E0-4AD0-A817-DC807B20E808"></p><a id="more"></a><p><strong>ThreadLocal 原理</strong>：每个 Thread 内维护着一个 ThreadLocalMap，它是一个 Map,这个映射表中 Key 为一个弱引用，就是 ThreadLocal 本身，value 就是我们存储的对象。</p><p>也就是说 ThreadLocal 是一个工具，来维护 ThreadLocalMap 来存取数值，注意图上的虚线，它代表一个弱引用，而弱引用的生命周期只能存活在下一次 GC.</p><h1 id="ThreadLocal-为什么出现内存泄漏"><a href="#ThreadLocal-为什么出现内存泄漏" class="headerlink" title="ThreadLocal 为什么出现内存泄漏"></a>ThreadLocal 为什么出现内存泄漏</h1><p>ThreadLocal 在 ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果 ThreadLocal 没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取 ThreadLocalMap 中的元素是无法通过 null Key 来找到 Value 的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。</p><p>但是JVM团队已经考虑到这样的情况，并做了一些措施来保证 ThreadLocal 尽量不会内存泄漏：在 ThreadLocal 的get()、set()、remove()方法调用的时候会清除掉线程 ThreadLocalMap 中所有 Entry 中 Key 为 null 的 Value，并将整个 Entry 设置为 null，利于下次内存回收。</p><p>来看看ThreadLocal的get()方法底层实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用map.getEntry(this)时，内部会判断key是否为null，继续看map.getEntry(this)源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getEntry方法中，如果Entry中的key发现是null，会继续调用getEntryAfterMiss(key, i, e)方法，其内部回做回收必要的设置，继续看内部源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意k == null这里，继续调用了expungeStaleEntry(i)方法，expunge的意思是擦除，删除的意思，见名知意，在来看expungeStaleEntry方法的内部实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// expunge entry at staleSlot（意思是，删除value，设置为null便于下次回收）</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里，将当前Entry删除后，会继续循环往下检查是否有key为null的节点，如果有则一并删除，防止内存泄漏。但这样也并不能保证 ThreadLoca l不会发生内存泄漏，例如：</p><ul><li>使用 static 的 ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li><li>分配使用了 ThreadLocal 又不再调用get()、set()、remove()方法，那么就会导致内存泄漏。</li></ul><h3 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h3><p>从表面上看，发生内存泄漏，是因为Key使用了弱引用类型。但其实是因为整个Entry的key为null后，没有主动清除value导致。很多文章大多分析ThreadLocal使用了弱引用会导致内存泄漏，但为什么使用弱引用而不是强引用？</p><p>官方文档的说法：</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了处理非常大和生命周期非常长的线程，哈希表使用弱引用作为 key。</p></blockquote><p>下面我们分两种情况讨论：</p><ul><li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li><li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</li></ul><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p><ul><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li></ul><p>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal-原理&quot;&gt;&lt;a href=&quot;#ThreadLocal-原理&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 原理&quot;&gt;&lt;/a&gt;ThreadLocal 原理&lt;/h2&gt;&lt;p&gt;由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/12/threadlocal内存泄漏/F352F038-78E0-4AD0-A817-DC807B20E808.png&quot; alt=&quot;F352F038-78E0-4AD0-A817-DC807B20E808&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从复制和读写分离过程</title>
    <link href="http://yoursite.com/2019/06/23/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/06/23/mysql主从复制和读写分离过程/</id>
    <published>2019-06-23T07:08:25.000Z</published>
    <updated>2019-08-13T07:24:57.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><p><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</p></li><li><p><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</p></li><li><p><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/WX20190813-151216@2x.png" alt></p></li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="http://pw5y8kqa5.bkt.clouddn.com/WX20190813-152300@2x.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h2&gt;&lt;p&gt;主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;bin
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://yoursite.com/2019/06/10/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/06/10/mysql索引/</id>
    <published>2019-06-10T08:38:15.000Z</published>
    <updated>2019-08-12T09:00:12.452Z</updated>
    
    <content type="html"><![CDATA[<p>想必大家一提到索引都不陌生，在工作中经常接触到。比如我们一个 SQL 查询比较慢的时候，我们会给某个字段添加索引这样的方法来解决。</p><p>一句话简单的说，索引的出现就是为了提高查询的效率，就像书的目录一样。一本书有 1000 页，如果我们想要快速找到其中某一个知识点，如果不借助目录，我们查询可能会花费比较长的时间，如果我们借助目录的话，可以对我们查找的效率有了很明显的提升。其实对于数据库表而言，索引就是它的“目录”。</p><a id="more"></a><h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>索引的出现是为了提高查询效率，实现索引的方式有很多，比较常见的有哈希表、有序数组、和搜索树。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p> 哈希表是一种 key-value 存储的数据结构，我们只要输入带查找的的数值 key,就可以找到相对应的数值 value。哈希表的思路非常简单，我们把数值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地是多个 key 数值经过哈希函数的换算，会出现同一个数值的情况。处理这种昂情况的一种方法是，拉出一个链表。（这里就跟 JDK 中的 HashMap 中的处理类似 ）</p><p><img src="/2019/06/10/mysql索引/FE4B01D7-65BB-48F2-8E75-D84DDDB97273.png" alt="FE4B01D7-65BB-48F2-8E75-D84DDDB97273"></p><p>图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p><p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了。所以，<strong>哈希表这种结构适用于只有等值查询的场景，</strong>比如 Memcached 及其他一些 NoSQL 引擎。<strong>而有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例。那么我如果使用有序数组的话。</p><h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p><img src="/2019/06/10/mysql索引/WX20190812-165307@2x.png" alt></p><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到 ID_card_X（如果不存在ID_card_X，就找到大于 ID_card_X 的第一个User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2018年某个城市的所有人口信息，这类不会再修改的数据。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="/2019/06/10/mysql索引/WX20190812-165402@2x.png" alt></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>我们可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>nnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p><p><strong>每一个索引在InnoDB里面对应一棵B+树。</strong></p><p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p><p>这个表的建表语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key,</span><br><span class="line">k int not null,</span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB</span><br></pre></td></tr></table></figure><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下.</p><p><img src="/2019/06/10/mysql索引/WX20190812-165415@2x.png" alt></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p><strong>主键索引的叶子节点存的是整行数据</strong>。在InnoDB里，<strong>主键索引也被称为聚簇索引</strong>（clustered index）。</p><p><strong>非主键索引的叶子节点内容是主键的值</strong>。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>索引只能定位到 page, page 内部有个有序数组，通过二分法进行查找具体的数据。</p><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ol><li>只有一个索引；</li><li>该索引必须是唯一索引。</li></ol><p>这就是典型的KV场景。</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p><p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想必大家一提到索引都不陌生，在工作中经常接触到。比如我们一个 SQL 查询比较慢的时候，我们会给某个字段添加索引这样的方法来解决。&lt;/p&gt;
&lt;p&gt;一句话简单的说，索引的出现就是为了提高查询的效率，就像书的目录一样。一本书有 1000 页，如果我们想要快速找到其中某一个知识点，如果不借助目录，我们查询可能会花费比较长的时间，如果我们借助目录的话，可以对我们查找的效率有了很明显的提升。其实对于数据库表而言，索引就是它的“目录”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>count(1) 和 count(*)的区别</title>
    <link href="http://yoursite.com/2019/05/13/count-1-%E5%92%8Ccount-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/13/count-1-和count-的区别/</id>
    <published>2019-05-13T09:32:19.000Z</published>
    <updated>2019-08-11T14:54:15.259Z</updated>
    
    <content type="html"><![CDATA[<p>Count 是一种简单的聚合函数，一般也是我们第一个开始学习的聚合函数，那么他们之间究竟有什么区别呢？</p><p>有人说 count(1) 和 count(*) 他们之间有区别，而有的人说他们之间没有区别那么他们之间到底有没有区别呢？</p><a id="more"></a><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>count(1) 和 count(*) 之间没有区别，因为 count(*) 、count(1) 都不会去空值。单count(列名) 就有区别了，因为 count(列名) 回去过滤控制。</p><h2 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h2><p>他们之间根据不同情况会有些许区别，MySQL会对count（*）做优化。</p><ol><li>如果列为主键，count(列名)效率优于count(1) </li><li>如果列不为主键，count(1)效率优于count(列名)  </li><li>如果表中存在主键，count(主键列名)效率最优  </li><li>如果表中只有一列，则count(*)效率最优  </li><li>如果表有多列，且不存在主键，则count(1)效率优于count(*)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Count 是一种简单的聚合函数，一般也是我们第一个开始学习的聚合函数，那么他们之间究竟有什么区别呢？&lt;/p&gt;
&lt;p&gt;有人说 count(1) 和 count(*) 他们之间有区别，而有的人说他们之间没有区别那么他们之间到底有没有区别呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://yoursite.com/2019/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/13/数据库优化/</id>
    <published>2019-05-13T09:15:32.000Z</published>
    <updated>2019-08-11T15:11:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>数据库是我们开发中会经常使用到，那我们今天来聊一下在数据库方面所发生的问题，今天我主要学习了一下这个三个方面的知识，来给大家分享一下。</p><ol><li>库表设计 ？</li><li>慢 SQL 问题 ？</li><li>误操作、程序 bug 时怎么办 ？</li></ol><a id="more"></a><h2 id="一、库表设计"><a href="#一、库表设计" class="headerlink" title="一、库表设计"></a>一、库表设计</h2><h3 id="1-1-引擎的选择"><a href="#1-1-引擎的选择" class="headerlink" title="1.1 引擎的选择"></a>1.1 引擎的选择</h3><p>在 mysql 5.1 中，引入了新的插件式存储引擎体系结构，允许将存储引擎加载到正在运新的 mysql 服务器中。使用 mysql 插件式存储引擎体系结构，允许数据库专业人员或者设计库表的软件开发人员为特定的应用需求选择专门的存储引擎，完全不需要管理任何特殊的应用编码要求，也无需考虑所有的底层实施细节。因此，尽管不同的存储引擎具有不同的能力，应用程序是与之分离的。此外，使用者可以在服务器、数据库和表格三个层级中存储引擎，提供了极大的灵活性。</p><p>mysql 常用的存储引擎包括 MYISAM、Innodb 和 Memory，其中各自的特点如下：</p><ol><li>MYISAM : 全表锁，拥有较高的执行速度，一个写请求请阻塞另外相同表格的所有读写请求，并发性能差，占用空间相对较小，mysql 5.5 及以下仅 MYISAM 支持全文索引，不支持事务。</li><li>Innodb：行级锁（SQL 都走索引查询），并发能力相对强，占用空间是 MYISAM 的 2.5 倍，不支持全文索引（5.6 开始支持），支持事务。</li><li>Memory : 全表锁，存储在内存当中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重启时会丢失。</li></ol><blockquote><p>基于以上特性，建议绝大部份都设置为 innodb 引擎，特殊的业务再考虑选用 MYISAM 或 Memory ，如全文索引支持或极高的执行效率等。</p></blockquote><h3 id="1-2-分表的方法"><a href="#1-2-分表的方法" class="headerlink" title="1.2 分表的方法"></a>1.2 分表的方法</h3><p>数据库表使用过程中，为了减小数据库服务器的负担、缩短查询时间，常常会考虑做分表设计。分表分两种，一种是纵向分表（将本来可以在同一个表的内容，人为划分存储在为多个不同结构的表）和横向分表（把大的表结构，横向切割为同样结构的不同表）。</p><p>其中，纵向分表常见的方式有根据活跃度分表、根据重要性分表等。其主要解决问题如下：</p><ol><li>表与表之间资源争用问题；</li><li>锁争用机率小；</li><li>实现核心与非核心的分级存储，如UDB登陆库拆分成一级二级三级库；</li><li>解决了数据库同步压力问题。</li></ol><p>横向分表是指根据某些特定的规则来划分大数据量表，如根据时间分表。其主要解决问题如下：</p><ol><li>单表过大造成的性能问题；</li><li>单表过大造成的单服务器空间问题。</li></ol><h3 id="1-3-索引问题"><a href="#1-3-索引问题" class="headerlink" title="1.3 索引问题"></a><strong>1.3 索引问题</strong></h3><p>索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于更快地获取信息。 mysql 有四种不同的索引类型：</p><ol><li><ol><li>主键索此 ( PRIMARY )</li><li>唯一索引 ( UNIQUE )</li><li>普通索引 ( INDEX )</li><li>全文索引（FULLTEXT , MYISAM 及 mysql 5.6 以上的 Innodb ）</li></ol></li></ol><p>建立索引的目的是加快对表中记录的查找或排序，索引也并非越多越好，因为创建索引是要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间维护索引。</p><p>在设计表或索引时，常出现以下几个问题：</p><ol><li>少建索引或不建索引。这个问题最突出，建议建表时 DBA 可以一起协助把关</li><li>索引滥用。滥用索引将导致写请求变慢，拖慢整体数据库的响应速度（5.5 以下的 mysql 只能用到一个索引)。</li><li>从不考虑联合索引。实际上联合索引的效率往往要比单列索引的效率更高。</li><li>非最优列选择。低选择性的字段不适合建单列索引，如 status 类型的字段。</li></ol><h2 id="二、慢-SQL-问题"><a href="#二、慢-SQL-问题" class="headerlink" title="二、慢 SQL 问题"></a>二、慢 SQL 问题</h2><h3 id="2-1-导致慢-SQL-的原因"><a href="#2-1-导致慢-SQL-的原因" class="headerlink" title="2.1 导致慢 SQL 的原因"></a><strong>2.1 导致慢 SQL 的原因</strong></h3><p>在遇到慢 SQL 情况时，不能简单的把原因归结为 SQL 编写问题(虽然这是最常见的因素)，实际上导致慢 SQL 有很多因素，甚至包括硬件和 mysql 本身的 bug。根据出现的概率从大到小，罗列如下：</p><ol><li>SQL编写问题</li><li>锁</li><li>业务实例相互干绕对 IO/CPU 资源争用</li><li>服务器硬件</li><li>MYSQL BUG</li></ol><h3 id="2-2-由-SQL-编写导致的慢-SQL-优化"><a href="#2-2-由-SQL-编写导致的慢-SQL-优化" class="headerlink" title="2.2 由 SQL 编写导致的慢 SQL 优化"></a><strong>2.2 由 SQL 编写导致的慢 SQL 优化</strong></h3><p>针对SQL编写导致的慢 SQL，优化起来还是相对比较方便的。正如上一节提到的正确的使用索引能加快查询速度，那么我们在编写 SQL 时就需要注意与索引相关的规则：</p><ol><li>字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；</li><li>mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；</li><li>不要在字段前面加减运算；</li><li>字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；</li><li>like % 在前面用不到索引；</li><li>根据联合索引的第二个及以后的字段单独查询用不到索引；</li><li>不要使用 select *；</li><li>排序请尽量使用升序 ;</li><li>or 的查询尽量用 union 代替 （Innodb）；</li><li>复合索引高选择性的字段排在前面；</li><li>order by / group by 字段包括在索引当中减少排序，效率会更高。</li></ol><p>除了上述索引使用规则外，SQL 编写时还需要特别注意一下几点：</p><ol><li>尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；</li><li>分页语句 limit 的问题；</li><li>删除表所有记录请用 truncate，不要用 delete；</li><li>不让 mysql 干多余的事情，如计算；</li><li>输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；</li><li>在 Innodb上用 select count(*)，因为 Innodb 会存储统计信息；</li><li>慎用 Oder by rand()。</li></ol><h2 id="三、分析诊断工具"><a href="#三、分析诊断工具" class="headerlink" title="三、分析诊断工具"></a><strong>三、分析诊断工具</strong></h2><p>在日常开发工作中，我们可以做一些工作达到预防慢 SQL 问题，比如在上线前预先用诊断工具对 SQL 进行分析。常用的工具有：</p><ol><li>mysqldumpslow</li><li>mysql profile</li><li>mysql explain</li></ol><p>具体使用及分析方法在此就不赘述，网上有丰富的资源可以参考。</p><h2 id="四、误操作、程序-bug-时怎么办"><a href="#四、误操作、程序-bug-时怎么办" class="headerlink" title="四、误操作、程序 bug 时怎么办"></a><strong>四、误操作、程序 bug 时怎么办</strong></h2><p>当你发现误操作或程序 bug 导致线上数据被误删或误改动时，一定不能慌乱，应及时与 DBA 联系，第一时间进行数据恢复（严重时直接停止服务），尽可能减少影响和损失。对于重要数据（如资金）的操作，在开发时一定要反复进行测试，确保没有问题后再上线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库是我们开发中会经常使用到，那我们今天来聊一下在数据库方面所发生的问题，今天我主要学习了一下这个三个方面的知识，来给大家分享一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;库表设计 ？&lt;/li&gt;
&lt;li&gt;慢 SQL 问题 ？&lt;/li&gt;
&lt;li&gt;误操作、程序 bug 时怎么办 ？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化</title>
    <link href="http://yoursite.com/2019/05/12/JVM%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/12/JVM优化/</id>
    <published>2019-05-12T03:42:43.000Z</published>
    <updated>2019-08-11T05:25:14.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM运行参数"><a href="#JVM运行参数" class="headerlink" title="JVM运行参数"></a>JVM运行参数</h2><h3 id="三种参数类型"><a href="#三种参数类型" class="headerlink" title="三种参数类型"></a>三种参数类型</h3><ul><li><p>标准参数</p><ul><li>-help</li><li>-version</li><li>-D 设置程序运行的参数</li><li>-server  使用并行的垃圾收集器，启动慢，运行快</li><li>-client 使用串行的垃圾收集器，启动快，运行慢</li></ul></li><li><p>-X参数（非标准参数）</p><ul><li>-Xint </li><li>-Xcomp</li><li>-Xmixed</li><li>-Xms 堆的初始大小</li><li>-Xmx 堆的最大大小</li></ul></li><li><p>-XX 参数（使用率较高）</p><ul><li>-XX: newSize</li><li>-XX:+UseSerialGC</li><li>-XX:newRadio</li><li>-XX:+PrintFlagsFinal 输出JVM运行时的参数</li></ul></li></ul><p><img src="/2019/05/12/JVM优化/E:/Git\TTMS\MX-Notes\image\1557634794531.png" alt="1557634794531"></p><p>jps</p><p>jinfo -flags 进程id</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM运行参数&quot;&gt;&lt;a href=&quot;#JVM运行参数&quot; class=&quot;headerlink&quot; title=&quot;JVM运行参数&quot;&gt;&lt;/a&gt;JVM运行参数&lt;/h2&gt;&lt;h3 id=&quot;三种参数类型&quot;&gt;&lt;a href=&quot;#三种参数类型&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>一次完整的http请求过程</title>
    <link href="http://yoursite.com/2019/05/11/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/11/一次完整的http请求过程/</id>
    <published>2019-05-11T13:55:48.000Z</published>
    <updated>2019-08-11T05:25:14.657Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器上输入 <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 然后回车，回车这一瞬间到底发生了什么？</p><p>首先是域名解析，然后是建立 TCP 三次握手，建立 TCP 连接之后发起 HTTP 请求，服务器响应请求，浏览器获得 HTML 代码，浏览器解析 HTML 代码，并请求 HTML 代码中的资源，浏览器开始对页面进行渲染将页面呈现给用户。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><ul><li>首先浏览器会搜索自身的 DNS 缓存，如果有该条目，如果没有过期则返回。</li><li>如果浏览器缓存中没有找到，此时会查找操作系统本地 DNS 缓存，查看方式 ipconfig/displaydns。</li><li>如果操作系统的 DNS 缓存没有查找到则开始读取 host 文件的缓存，如果有则解析成功。</li><li>如果 host 文件中没有找到则计算机发起一个 DNS 的系统调用，向本地配置的 DNS 服务器发送一个域名解析的请求，运营商的 DNS 服务器首先会查找本地缓存，如果有则解析成功，如果没有则 DNS 服务器会代替我们浏览器发起迭代的请求，首先想根域名，然后从右向左，逐一进行请求。</li></ul><p>浏览器拿到 index.html 文件后，就开始解析其中的 html 代码，遇到 js/css/image 等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上 keep-alive 特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p><p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个 http 请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在浏览器上输入 &lt;a href=&quot;http://www.xxx.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.xxx.com&lt;/a&gt; 然后回车，回车这一瞬间到底发生了什么？&lt;/p&gt;
&lt;p&gt;首先是域名解析，然后是建立 TCP 三次握手，
      
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>事务的隔离级别和传播机制</title>
    <link href="http://yoursite.com/2019/05/11/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/11/事务的隔离级别和传播机制/</id>
    <published>2019-05-11T13:54:43.000Z</published>
    <updated>2019-08-11T05:25:14.657Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://yoursite.com/2019/05/10/redis/"/>
    <id>http://yoursite.com/2019/05/10/redis/</id>
    <published>2019-05-10T00:14:55.000Z</published>
    <updated>2019-08-11T05:25:14.656Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进程和线程</title>
    <link href="http://yoursite.com/2019/05/10/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/10/进程和线程/</id>
    <published>2019-05-09T16:23:53.000Z</published>
    <updated>2019-08-11T05:25:14.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程的切换过程"><a href="#进程的切换过程" class="headerlink" title="进程的切换过程"></a>进程的切换过程</h2><p>用户态发生系统调用进入内核态</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>进程是资源分配的最小单位，线程是 CUP 调度的最小单位。</li><li>所有与进程相关的资源都被记录在 PCB 中。</li><li>进程是抢占处理机的调度单位，线程属于某个进程，共享其资源</li><li>线程只由堆栈寄存器、程序计数器和 TCB 组成</li><li>线程不能看做独立的应用，而进程可看做独立应用</li><li>进程有独立的地址空间，相互影响，线程只是进程的不同执行路径</li><li>线程没有独立的地址空间，多进程的程序比多线程程序健壮</li><li>进程的切换比线程切换开销大</li></ul><h2 id="进程的通信实现"><a href="#进程的通信实现" class="headerlink" title="进程的通信实现"></a>进程的通信实现</h2><ul><li><p>管道</p><p>半双工，速度慢，容量有限，只能父子间通信</p></li><li><p>命名管道</p></li><li><p>FIFO</p><p>任何进程间都能通信，速度慢</p></li><li><p>信号量</p><p>不能传递复杂消息，只能同步</p></li><li><p>共享内存</p><p>能够很容易控制容量，速度快</p></li></ul><h2 id="线程的通信实现"><a href="#线程的通信实现" class="headerlink" title="线程的通信实现"></a>线程的通信实现</h2><ul><li><p><strong>wait/notify机制</strong></p><p><strong>wait : </strong>让当前线程释放对象锁，并进入阻塞状态。</p><p><strong>notify :</strong>唤醒一个正在等待相应对象锁的线程，使其进入同步队列，以便在当前线程释放锁后竞争所，进而得到 CPU 的执行。在执行 notify 方法之后，当前线程并不能马上释放锁对象，呈 wait 状态的线程也并不能马上获取该对象锁，只有执行 notify 方法的线程退出 synchronized 代码块/方法后,当前线程才会释放锁，而呈 wait 状态的线程才会去竞争锁。</p><p><strong>notityAll :</strong>唤醒所有正在等待相应对象锁的线程。</p></li><li><p><strong>Condition</strong></p><p><strong>await</strong></p><p><strong>singal</strong></p><p><strong>singalAll</strong></p></li><li><p><strong>生产者消费者模型</strong></p></li><li><p><strong>管道 PipedOutStream/PipedInputStream</strong></p></li><li><p><strong>Join</strong></p><p>假如在main线程中调用thread.join方法，则main线程会等待thread线程执行完毕或者等待一定的时间。join 是调用 wait 方法实现，同样会让宿主线程交出 CPU 的执行权限，会让线程释放对一个对象持有的锁，如果调用了 join 方法，必须捕获 InterruptedException 异常或者将该异常向上层抛出。</p></li></ul>]]></content>
    
    <summary type="html">
    
      学习关于进程和线程的相关知识点
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Http 和 Https的区别</title>
    <link href="http://yoursite.com/2019/05/09/Http-%E5%92%8C-Https%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/09/Http-和-Https的区别/</id>
    <published>2019-05-09T15:56:33.000Z</published>
    <updated>2019-08-11T15:19:16.021Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们经常使用到 http 协议和 https 协议，那他们之间有什么区别呢？</p><p>他们的基本概念是什么呢？我们今天来学习一下。</p><a id="more"></a><h2 id="详细解析-HTTP-与-HTTPS-的区别"><a href="#详细解析-HTTP-与-HTTPS-的区别" class="headerlink" title="详细解析 HTTP 与 HTTPS 的区别"></a>详细解析 HTTP 与 HTTPS 的区别</h2><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在HTTP的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h2 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a><strong>HTTP和HTTPS的基本概念</strong></h2><p><strong>HTTP</strong>：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p><strong>HTTPS</strong>：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP下 加入SSL层，HTTPS 的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p><strong>HTTPS 协议的主要作用可以分为两种</strong>：</p><ul><li>建立一个信息安全通道，来保证数据传输的安全。</li><li>确认网站的真实性。</li></ul><h2 id="HTTP与HTTPS有什么区别"><a href="#HTTP与HTTPS有什么区别" class="headerlink" title="HTTP与HTTPS有什么区别"></a><strong>HTTP与HTTPS有什么区别</strong></h2><ul><li>https 协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http 的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</li></ul><h2 id="数据传输安全的意思？"><a href="#数据传输安全的意思？" class="headerlink" title="数据传输安全的意思？"></a>数据传输安全的意思？</h2><ul><li>客户端和服务器之间的通信只能又自己看得懂，第三方拿到数据也看不懂这些信息的真实含义。</li><li>第三方虽然看不懂，但是可以对数据篡改，因此客户端和服务端必须有能力判断数据是否被修改过。</li><li>客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。</li></ul><h2 id="怎么加密信息？"><a href="#怎么加密信息？" class="headerlink" title="怎么加密信息？"></a>怎么加密信息？</h2><p>使用对称秘钥和非对称秘钥进行加密，对称秘钥是加密和解密都用相同的秘钥进行。非对称秘钥有两个秘钥，一个公钥和一个私钥。公钥加密的内容只有通过私钥才能解密，私钥加密的内容只有通过公钥进行解密。使用对称加密一般比非对称加密快得多，对服务器的运算压力也小。</p><h2 id="对称秘钥怎么传输"><a href="#对称秘钥怎么传输" class="headerlink" title="对称秘钥怎么传输?"></a>对称秘钥怎么传输?</h2><p>服务器明文传输对称秘钥是不安去的，如果监听者拿到对称秘钥，以后的通信内容就被破解了。所以不能明文传输对称秘钥，而且不能用一个新的对称秘钥来加密原来的对称秘钥，否则新的对称秘钥同样无法传输，就是鸡生蛋，蛋生鸡的驳论。</p><p>这里我们采用非对称加密的方式，非对称加密的特性决定了服务器用私钥加密的内容并不是真正的加密，因为公钥所有人都有，所以服务器的密文能被所有人解析，但是私钥只掌握在服务器手上，这就带来了两个好的优势：</p><ul><li>服务器下发的内容不能被伪造，因为别人都没有私钥，只有服务器有，所以无法加密。强行加密的后果是客户端使用公钥都无法完成解密。</li><li>任何人用公钥加密的内容都是绝对安全的，因为私钥只有服务端有，也就是只有真正的服务器可以看到加密的原文</li></ul><p>所以传输对称秘钥的问题就迎刃而解了：秘钥不是由服务器下发的，而是由客户端生成并主动高数服务器。所以当引入非对称加密后，HTTPS的握手流程依然是两部，不过细节略有变化：</p><p>​    客户端：你好，我要发起一个HTTPS的请求，这是我的秘钥（用公钥加密后的）</p><p>​    服务端：好的，我知道你的秘钥了，后续就用它来传输。</p><h2 id="公钥怎么传输？"><a href="#公钥怎么传输？" class="headerlink" title="公钥怎么传输？"></a>公钥怎么传输？</h2><p>对公钥进行加密，每一个HTTPS服务器都必须去专门的证书机构注册一个证书，证书中存储了用权威机构私钥加密的公钥。这样客户端用权威机构的公钥解密就可以了。</p><p>现在HTTPS协议握手阶段变成四步：</p><ol><li>客户端：你好，我要发起一个HTTPS请求，请给我公钥</li><li>服务器：好的，这是我的证书，里面有加密后的公钥</li><li>客户端：解密成功以后告诉服务器，这是我的对称秘钥</li><li>服务器：好的，我知道了你的秘钥了，后续就用它来传输吧。</li></ol><h2 id="那么权威机构的公钥怎么传输呢？"><a href="#那么权威机构的公钥怎么传输呢？" class="headerlink" title="那么权威机构的公钥怎么传输呢？"></a>那么权威机构的公钥怎么传输呢？</h2><p>这个公钥不用传输，会直接内置在各大操作系统或者浏览器的出厂设置里。之所以不把每个服务器的公钥内置在电脑里，一方面服务器太多，存不过来。另一方面操作系统也不信任你，凭什么你说你这个就是百度的证书呢。所以各个公司先去权威机构认证，申请证书，然后操作系统只会存储权威机构的公钥。因为权威机构数量有限，所以操作系统厂商相对来说容易管理。如果这个权威机构不够权威，胡乱发证书，就会取消他的资格，比如可怜的沃通。</p><h2 id="怎么知道证书没有被篡改？"><a href="#怎么知道证书没有被篡改？" class="headerlink" title="怎么知道证书没有被篡改？"></a>怎么知道证书没有被篡改？</h2><p>将信息哈希值随着信息一起传递。为了保证证书没有篡改，我们可以在传递证书的同时传递的哈希值。由于第三者无法解析数据，只能胡乱改，那么修改后的数据在解密后，就不能通过哈希。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中我们经常使用到 http 协议和 https 协议，那他们之间有什么区别呢？&lt;/p&gt;
&lt;p&gt;他们的基本概念是什么呢？我们今天来学习一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>线程池使用总结</title>
    <link href="http://yoursite.com/2019/05/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/09/线程池使用总结/</id>
    <published>2019-05-09T14:00:43.000Z</published>
    <updated>2019-08-11T05:25:14.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><img src="/2019/05/09/线程池使用总结/1557327261076.png" alt></p><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><p><img src="/2019/05/09/线程池使用总结/1557327546254.png" alt></p><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p><img src="/2019/05/09/线程池使用总结/1557327451978.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程池的好处&quot;&gt;&lt;a href=&quot;#线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;线程池的好处&quot;&gt;&lt;/a&gt;线程池的好处&lt;/h2&gt;&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池
      
    
    </summary>
    
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>spring回滚事务的处理思路</title>
    <link href="http://yoursite.com/2019/05/09/spring%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/05/09/spring回滚事务的处理思路/</id>
    <published>2019-05-09T13:48:02.000Z</published>
    <updated>2019-08-11T15:16:05.197Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用中经常使用 spring，但是我们是否真正的理解当事务发生回滚的时候spring 是怎么给我处理的吗？是否会回滚呢，现在让我们来一起看看吧。</p><a id="more"></a><h2 id="spring-try-…-catch-事务不回滚的处理思路"><a href="#spring-try-…-catch-事务不回滚的处理思路" class="headerlink" title="spring try {…} catch {} 事务不回滚的处理思路"></a>spring try {…} catch {} 事务不回滚的处理思路</h2><p>当希望在某个方法中添加事务时，我们常常在方法头上添加@Transactional注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易让人忽略的是：方法上未加任何属性的 @Transactional 注解只能在抛出 RuntimeException 或者 Error 时才会触发事务的回滚，常见的 非RuntimeException 是不会触发事务的回滚的。</p><p>如果要在抛出 非RuntimeException时也触发回滚机制，需要我们在注解上添加 rollbackFor = { Exception.class }属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = &#123; Exception.class &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面事务回滚的前提是添加 @Transactional 注解的方法中不含有 try{…}catch{…} 异常，使得程序运行过程中出现异常能顺利抛出，从而触发事务回滚。</p><p>在实际开发中，我们往往需要在方法中进行异常的捕获，从而对异常进行判断，为客户端返回提示信息。但是此时由于异常的被捕获，导致事务的回滚没有被触发，导致事务的失败。</p><p>下面提供几种解决方法：</p><h3 id="1-使用-Transactional注解，抛出-Transactional注解默认识别的RuntimeException"><a href="#1-使用-Transactional注解，抛出-Transactional注解默认识别的RuntimeException" class="headerlink" title="1. 使用@Transactional注解，抛出@Transactional注解默认识别的RuntimeException"></a>1. 使用@Transactional注解，抛出@Transactional注解默认识别的RuntimeException</h3><p>方法上使用@Transactional注解，在捕获到异常时在catch语句中抛出RuntimeException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理返回消息</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-Transactional-rollbackFor-Exception-class-，抛出捕获的非RuntimeException异常"><a href="#2-使用-Transactional-rollbackFor-Exception-class-，抛出捕获的非RuntimeException异常" class="headerlink" title="2. 使用@Transactional(rollbackFor = { Exception.class })，抛出捕获的非RuntimeException异常"></a>2. 使用@Transactional(rollbackFor = { Exception.class })，抛出捕获的非RuntimeException异常</h3><p>方法上使用@Transactional(rollbackFor = { Exception.class })注解声明事务回滚级别，在捕获到异常时在catch语句中直接抛出所捕获的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = &#123; Exception.class &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理返回消息</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-手动回滚"><a href="#3-手动回滚" class="headerlink" title="3. 手动回滚"></a>3. 手动回滚</h3><p>上面两个在catch{…}中抛出异常的方法都有个不足之处，就是不能在catch{…}中存在return子句，所以设置手动回滚，当捕获到异常时，手动回滚，同时返回前台提示信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="comment">// 手动回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用中经常使用 spring，但是我们是否真正的理解当事务发生回滚的时候spring 是怎么给我处理的吗？是否会回滚呢，现在让我们来一起看看吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见问题总结</title>
    <link href="http://yoursite.com/2019/05/09/MQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/09/MQ常见问题/</id>
    <published>2019-05-09T12:12:15.000Z</published>
    <updated>2019-08-11T05:25:14.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ常见问题"><a href="#MQ常见问题" class="headerlink" title="MQ常见问题"></a>MQ常见问题</h1><p>消息队列核心解决的问题主要是：异步、解耦、消息切峰。异步、解耦、消峰填谷这是消息队列最大的优点，除了这些消息队列还可以会解决一些我们特殊业务场景的问题。但是缺点主要在于系统的可用性、复杂性、一致性问题，引入消息队列后，需要考虑MQ的可用性，万一MQ崩溃了岂不是要爆炸？而且复杂性明显提高了，需要考虑一些消息队列的常见问题和解决方案，还有就是一致性问题，一条消息由多个消费者消费，万一有一个消费者消费失败了，就会导致数据不一致。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul><li>单机吞吐量：万级别</li><li>失效性：微秒级别</li><li>可用性：基于主从架构</li></ul><p>RabbitMQ现在使用的较为多一些，社区活跃度也很高，功能也很强大，官方还提供了管理的web界面，性能也很好，但是RabbitMQ性能好的主要原因是因为使用erlang语言开发的，erlang语言貌似天生性能好，但对于我们java开发者来说，源码基本看不懂，更别提深入的研究了，不过spring推出了rabbit的支持，貌似还比较好用，比自己去封装实现并且去处理一些问题的要好多了。</p><h2 id="RabbitMQ-模式"><a href="#RabbitMQ-模式" class="headerlink" title="RabbitMQ 模式"></a>RabbitMQ 模式</h2><ul><li><p>单机模式</p><p>单机模式通常是用来进行测试和开发的场景，测试一般是否能正确的处理数据，线上环境没人去用单机模式，风险大。</p></li><li><p>普通集群模式</p><p>普通集群模式就是启动多个 RabbitMQ 实例，在你创建queue只会放在一个 RabbitMQ上，但是每个实例都同步 queue 的元数据，在消费的时候，如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据，后者有数据拉取的开销，前者导致单实例性能瓶颈。而且如果那个放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作</p></li><li><p>镜像集群模式</p><p>镜像集群模式是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</p><p>优点在于你任何一个实例宕机了，没事儿，别的实例都可以用。缺点在于性能开销太大和扩展性很低，同步所有实例，这会导致网络带宽和压力很重，而且扩展性很低，每增加一个实例都会去包含已有的queue的所有数据，并没有办法线性扩展queue。</p><p>开启镜像集群模式可以去RabbitMQ的管理控制台去增加一个策略，指定要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p></li></ul><h2 id="如何保证消息的幂等性"><a href="#如何保证消息的幂等性" class="headerlink" title="如何保证消息的幂等性"></a>如何保证消息的幂等性</h2><p>消息重复消费的原因主要是在与回馈机制，在某些场景中我们采用回馈机制不同，原因也不同，比如消费者消费完成消息之后回复 ack ，但是刚消费完成还没有来的及提交，系统就重新启动。这时重新启动就会pull 消息的时候没有提高 ack ，消息还是上次的消息。</p><p>那么如何怎么来保证消息消费的幂等性呢？实际上我们只要保证多条相同的数据过来的时候只处理一条或者说多条处理和处理一条造成的结果相同即可，但是具体怎么做要根据业务需求来定，例如入库消息，先查一下消息是否已经入库啊或者说搞个唯一约束啊什么的，还有一些是天生保证幂等性就根本不用去管，例如redis就是天然幂等性。</p><p>还有一个问题，消费者消费消息的时候在某些场景下要放过消费不了的消息，遇到消费不了的消息通过日志记录一下或者搞个什么措施以后再来处理，但是一定要放过消息，因为在某些场景下例如spring-rabbitmq的默认回馈策略是出现异常就没有提交ack，导致了一直在重发那条消费异常的消息，而且一直还消费不了，这就尴尬了，后果你会懂的。</p><h2 id="消息遗漏"><a href="#消息遗漏" class="headerlink" title="消息遗漏"></a>消息遗漏</h2><p><strong>1）生产者弄丢了数据</strong><br>　　生产者将数据发送到RabbitMQ的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。此时可以选择用RabbitMQ提供的事务功能，就是生产者发送数据之前开启RabbitMQ事务（channel.txSelect），然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，RabbitMQ事务机制一搞，基本上吞吐量会下来，因为太耗性能。</p><p>　　所以一般来说，如果你要确保说写RabbitMQ的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了RabbitMQ中，RabbitMQ会给你回传一个ack消息，告诉你说这个消息ok了。如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>　　事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息RabbitMQ接收了之后会异步回调你一个接口通知你这个消息接收到了。</p><p>　　所以一般在生产者这块避免数据丢失，都是用confirm机制的。</p><p><strong>（2）RabbitMQ弄丢了数据</strong></p><p>　　就是RabbitMQ自己弄丢了数据，这个你必须开启RabbitMQ的持久化，就是消息写入之后会持久化到磁盘，哪怕是RabbitMQ自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p><h5 id="设置持久化有两个步骤"><a href="#设置持久化有两个步骤" class="headerlink" title="设置持久化有两个步骤"></a>设置持久化有两个步骤</h5><p>第一个是创建queue的时候将其设置为持久化的，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里的数据；</p><p>第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，RabbitMQ哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p><p>而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</p><p>哪怕是你给RabbitMQ开启了持久化机制，也有一种可能，就是这个消息写到了RabbitMQ中，但是还没来得及持久化到磁盘上，结果不巧，此时RabbitMQ挂了，就会导致内存里的一点点数据会丢失。</p><p><strong>（3）消费端弄丢了数据</strong></p><p>　　RabbitMQ如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ认为你都消费了，这数据就丢了。</p><p>　　这个时候得用RabbitMQ提供的ack机制，简单来说，就是你关闭RabbitMQ自动ack，可以通过一个api来调用就行，然后每次你自己代码里确保处理完的时候，在程序里ack一把。这样的话，如果你还没处理完，不就没有ack？那RabbitMQ就认为你还没处理完，这个时候RabbitMQ会把这个消费分配给别的consumer去处理，消息是不会丢的。</p><p>在发送消息的时候，接受时记录 DB 日志，定时轮询 DB 日志，查明那些发送的消息没有成功消费，启动重新发送消息机制。</p><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p><strong>场景： 比如下单操作，下单成功后，会发布创建订单和减库存的消息，但扣库存消息执行会先于创建订单的消息，也就说前者执行成功之后，才能执行后者。</strong></p><p>MQ 层面支持消息的顺序处理开销太大了，为了极少量的需求，增加了整体上的复杂性。应该尽可能的在应用层面进行处理。</p><p>解决方式如下：</p><ol><li>同步执行，当一个消息执行之后，再发送下一个消息。</li><li>rabbitmq：拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。</li></ol><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><p>如果消费端接受到两个一样的消息，应该如何处理呢？</p><ol><li>消费端处理消息的业务逻辑应该保持幂等性。</li><li>保证每条消息都有唯一标号，首先检查执行成功的日志中是否存有该消息的 ID 如果没有则执行，如果已经存在则丢弃消息。如果在消息系统中实现，会对消息系统的吞吐量造成影响。所以还是在业务端进行去重处理。</li></ol><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p> 具体来说，就是把消息的发送分成了2个阶段：Prepare阶段和确认阶段。</p><p>具体来说，上面的2个步骤，被分解成3个步骤：<br>(1) 发送Prepared消息<br>(2) update DB<br>(3) 根据update DB结果成功或失败，Confirm 或者取消 Prepared 消息。</p><p>可能有人会问了，前2步执行成功了，最后1步失败了怎么办？这里就涉及到了RocketMQ的关键点：RabbitMQ 会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？</p><h2 id="消息阻塞"><a href="#消息阻塞" class="headerlink" title="消息阻塞"></a>消息阻塞</h2><p><strong>上千万条消息在 mq 里积压了几个小时了还没解决</strong> </p><p>紧急扩容</p><p>1）先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉<br>2）新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量<br>3）然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<br>消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue<br>4）接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据<br>5）这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据<br>6）等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</p><h2 id="消息队列过期失效问题"><a href="#消息队列过期失效问题" class="headerlink" title="消息队列过期失效问题"></a>消息队列过期失效问题</h2><p>　假设你用的是rabbitmq，rabbitmq是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，这个数据就没了。晚上12点以后，用户都睡觉了。</p><p>　　这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把白天丢的数据给他补回来。也只能是这样了。</p><p>　　假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次。</p><h2 id="消息队列满"><a href="#消息队列满" class="headerlink" title="消息队列满"></a>消息队列满</h2><p>丢弃，晚上补数据</p>]]></content>
    
    <summary type="html">
    
      MQ 生产上遇到的一些问题和解决办法进行总结
    
    </summary>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://yoursite.com/2019/05/09/network/"/>
    <id>http://yoursite.com/2019/05/09/network/</id>
    <published>2019-05-09T11:44:25.000Z</published>
    <updated>2019-08-11T05:25:14.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层的任务就是通过应用进程间的交互来完成特定网络应用，应用层协议定义的的是应用进程间的通信和交互规则，对于不同的网路需要不同的应用层协议。我们把应用层交互的数据叫做报文。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>网络层只是把分组发送到目的主机，但是真正通信并不是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来好像在两个传输实体之间有一条端到端的逻辑通信信道。</p><h3 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h3><ul><li>用户数据协议 UDP 是无连接的，尽最大的可能提供交付，没有拥塞控制，面向报文（对应用层序传输下来的报文即不拆分也不合并，只是添加 UDP 首部），支持一对一，一对多，多对一，多对多的通信。</li><li>传输控制协议 TCP 是面向连接的，提供可靠的交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能点对点的通信。</li></ul><h3 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h3><ul><li><strong>序号：</strong> 用来对字节流进行编号。</li><li><strong>确认号：</strong>期望下次收到的报文段的序号。 </li><li><strong>数据偏移：</strong> 指数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认ACK：</strong> 当 ACK = 1 的确认号字段有效，否则无效，TCP 规定，在连接建立之后所有传输的报文段都必须把 ACK 设置为 1。</li><li><strong>同步SYN：</strong> 在连接建立时用来同步序号。当 SYN = 1，ACK = 0 时表示这是一个连接请求报文段。若对方同意建立连接则响应报文中 SYN = 1，ACK = 1。</li><li><strong>终止FIN：</strong> 用来释放一个连接，当 FIN = 1 的时候，表示报文端已经发送完毕，并要求释放连接。</li><li><strong>窗口：</strong> 窗口作为接收方让发送方设置其发窗口的依据。之所以要有要有这个限制，是因为接受方的数据缓存空间是有限的。</li></ul><h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p><img src="/2019/05/09/network/E:/Git\TTMS\MX-Notes\image\1557411990645.png" alt="1557411990645"></p><p>假设 A 为客户端，B 为服务端</p><ul><li>首先 B 处于监听状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN = 1, ACK = 0,选择一个初始的序号 x </li><li>B 收到请求报文之后，如果同意连接，则向 A 发送连接确认的报文，SYN = 1，ACK = 1,确认号为 x + 1,同时选择一个初始序号 y。</li><li>A 收到 B 的连接确认报文之后，还要向 B 发处确认，ACK = 1, 确认号为 y + 1,序号为 x + 1</li><li>B 收到 A 的确认后，连接建立</li></ul><h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><ul><li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误的打开连接。</li><li>客户端发送的连接请求在网络中滞留，那么会隔很长的时间才能收到服务端发来回来的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的确认连接确认，不进行第三次握手，因此就不会再次打开连接。</li></ul><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p><img src="/2019/05/09/network/E:/Git\TTMS\MX-Notes\image\1557412704769.png" alt="1557412704769"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h4 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a><strong>四次挥手的原因</strong></h4><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在计算机网络进行通信的两个计算机之间可能会经过多个数据链路，可能还要经过多个通信子网，网络层的任务就是选择合适的网络路由和交换节点，确保数据的及时发送。在发送数据的时候把运输层的数据报封装成组和包进行传送，网络层使用的协议是 IP 协议，因此分组也叫数据报。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>将网络层交下来的IP数据组装成帧。在两个相邻节点的链路上传送帧。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。</p>]]></content>
    
    <summary type="html">
    
      对网络层知识点学习总结，对每一层划分，对网络知识整体上有了认知
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java设计笔记</title>
    <link href="http://yoursite.com/2018/11/13/design/"/>
    <id>http://yoursite.com/2018/11/13/design/</id>
    <published>2018-11-12T16:47:01.000Z</published>
    <updated>2019-08-11T05:25:14.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Controller层"><a href="#一、Controller层" class="headerlink" title="一、Controller层"></a>一、Controller层</h4><ul><li>定义每个模块的restful接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user"</span>, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br></pre></td></tr></table></figure><ul><li>只负责控制逻辑与返回响应数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.OK.toString(), HttpStatus.OK);</span><br></pre></td></tr></table></figure><ul><li><p>每个controller添加日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br></pre></td></tr></table></figure></li><li><p>将request请求传递给业务层(service)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = userService.getUserName(Id, request)</span><br></pre></td></tr></table></figure></li><li><p>添加一个Template 和一个响应实体ResponseEntity&lt;&gt;将返回的数据放入模板中，然后将模板封装到响应实体之中，最后将相应实体发送给前端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserTemplate user = userService.getUserById(Id, request);</span><br><span class="line">ResponseEntity&lt;&gt;(user, HttpStatus.OK)</span><br></pre></td></tr></table></figure></li><li><p>针对不同的请求添加不同的注解</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/xxx"</span>) <span class="meta">@PosstMapping</span>(<span class="string">"/xxx"</span>) <span class="meta">@PutMapping</span>(<span class="string">"/xxx"</span>)</span><br></pre></td></tr></table></figure><ul><li>使用@PathVariable(value = “id”) 支持Restful</li><li>使用@RequestParam接受Request中的数据 </li><li>使用数据字典，将常量统一保存到指定的类中进行管理。</li></ul><h4 id="二、Service层"><a href="#二、Service层" class="headerlink" title="二、Service层"></a>二、Service层</h4><ul><li><p>分页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// SearchVo 封装了查询条件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getList</span><span class="params">(SearchVo searchVo, PageInfo pageInfo)</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取总行数</span></span><br><span class="line">    Integer totalSize = userMapper.getUserCount(searchVo);</span><br><span class="line">    <span class="comment">// 增强鲁棒性</span></span><br><span class="line">    <span class="keyword">if</span> (totalSize == <span class="keyword">null</span> || totalSize == <span class="number">0</span>) &#123;</span><br><span class="line">        pageInfo.setTotalSize(<span class="number">0</span>);</span><br><span class="line">        pageInfo.setPageCount(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageInfo.setTotalSize(totalSize);</span><br><span class="line">        pageInfo.setPageCount((<span class="keyword">int</span>) Math.ceil((totalSize * <span class="number">1.0</span>) /         ----(pageInfo.getPageSize() * <span class="number">1.0</span>)));        </span><br><span class="line">        Integer offset = (pageInfo.getPageNo() - <span class="number">1</span>) * pageInfo.getPageSize();</span><br><span class="line">        searchVo.setOffset(offset);</span><br><span class="line">        searchVo.setPageSize(pageInfo.getPageSize());</span><br><span class="line">        <span class="comment">// 查询数据</span></span><br><span class="line">        userList = userMapper.searchUser(searchVo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isEmpty() <span class="comment">//判断是否为空</span></span><br></pre></td></tr></table></figure></li><li><p>事务处理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = &#123;Throwable.class, Exception.class&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果出现异常向上抛出</p></li><li><p>数据的封装</p></li><li>业务的处理</li></ul><h4 id="三、-Mapper层"><a href="#三、-Mapper层" class="headerlink" title="三、 Mapper层"></a>三、 Mapper层</h4><ul><li>定制sql        </li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SelectProvider</span>(type = BookSQLProvider.class, method = <span class="string">"searchBook"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">getDsDashboardCount</span><span class="params">(SearchVo searchBean)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookSQLProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">searchBook</span><span class="params">(SearchVo searchBean)</span> </span>&#123;</span><br><span class="line">        StringBuffer sql = <span class="keyword">new</span> StringBuffer(<span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">"count(1)"</span>);</span><br><span class="line">            FROM(<span class="string">"db_book b, db_person p"</span>);</span><br><span class="line">            WHERE(<span class="string">"b.id = p.id"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(searchBean.getDashboardName()))&#123;</span><br><span class="line">                WHERE(<span class="string">"title like '"</span>+searchBean.getDashboardName()+<span class="string">"%'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(searchBean.getCreator())) &#123;</span><br><span class="line">                WHERE(<span class="string">"creator = #&#123;creator&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString());</span><br><span class="line">        <span class="keyword">return</span> sql.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>CRUD</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"INSERT INTO dp_report_dashboards (title) VALUES (#&#123;title&#125;)"</span>) <span class="comment">// 关键字大写</span></span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys=<span class="keyword">true</span>, keyProperty=<span class="string">"id"</span>) <span class="comment">// 主键自增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createDashboard</span><span class="params">(MetaDashboard dashboard)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="注解-Results"><a href="#注解-Results" class="headerlink" title="注解@Results"></a>注解@Results</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line"><span class="meta">@Result</span>(property = <span class="string">"id"</span>, column = <span class="string">"id"</span>, javaType = Long.class, jdbcType = JdbcType.BIGINT),</span><br><span class="line">    <span class="meta">@Result</span>(property = <span class="string">"book_price"</span>, column = <span class="string">"db_id"</span>, javaType = Long.class, jdbcType = JdbcType.BIGINT),</span><br><span class="line">    <span class="meta">@Result</span>(property = <span class="string">"image"</span>, column = <span class="string">"iamge"</span>, javaType = Image.class,many = <span class="meta">@many</span>(select = <span class="string">"com.mx.mappers.ImageMapper.getImageById"</span>)),</span><br><span class="line"><span class="meta">@Result</span>(</span><br><span class="line">    property = <span class="string">"company_id"</span>, column = <span class="string">"company_id"</span>, javaType = List.class,many = <span class="meta">@Many</span>(select =<span class="string">"com.mx.mappers.CompanyMapper.getInfoById"</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一些设计的技巧
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://yoursite.com/2018/09/27/annotion/"/>
    <id>http://yoursite.com/2018/09/27/annotion/</id>
    <published>2018-09-26T16:47:01.000Z</published>
    <updated>2019-08-11T05:25:14.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><ul><li>@Override，表示当前的方法定义将覆盖超类中的方法。</li><li>@Deprecated，使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</li><li>@SuppressWarnings，关闭不当编译器警告信息。</li></ul><p>我们可以创建自定义注解，为了创建自定义注解java还提供了4种源注解，专门负责注解的创建</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><h5 id="Target-：表示该注解可以用于什么地方，可能的ElementType参数有"><a href="#Target-：表示该注解可以用于什么地方，可能的ElementType参数有" class="headerlink" title="@Target ：表示该注解可以用于什么地方，可能的ElementType参数有"></a>@Target ：表示该注解可以用于什么地方，可能的ElementType参数有</h5><ul><li>CONSTRUCTOR：构造器的声明。</li><li>FIELD：域声明（包括enum实例）。</li><li>LOCAL_VARIABLE：局部变量声明。</li><li>METHOD：方法声明。</li><li>PACKAGE：包声明。</li><li>PARAMETER：参数声明。</li><li>TYPE：类、接口（包括注解类型）或enum声明。</li></ul><h5 id="Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括"><a href="#Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括" class="headerlink" title="@Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括"></a>@Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括</h5><ul><li>SOURCE：注解将被编译器丢弃。</li><li>CLASS：注解在class文件中可用，但会被VM丢弃。</li><li>RUNTIME：VM将在运行期间保留注解，因此可以通过反射机制读取注解的信息。</li></ul><h5 id="Document-：将注解包含在Javadoc中"><a href="#Document-：将注解包含在Javadoc中" class="headerlink" title="@Document ：将注解包含在Javadoc中"></a>@Document ：将注解包含在Javadoc中</h5><h5 id="Inherited-：-允许子类继承父类中的注解"><a href="#Inherited-：-允许子类继承父类中的注解" class="headerlink" title="@Inherited ： 允许子类继承父类中的注解"></a>@Inherited ： 允许子类继承父类中的注解</h5><h5 id="下面我创建一个名称为-Description的自定义注解"><a href="#下面我创建一个名称为-Description的自定义注解" class="headerlink" title="下面我创建一个名称为@Description的自定义注解"></a>下面我创建一个名称为@Description的自定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> maxu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 这里使用@interface 关键字来定义注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是声明一个成员变量，并且要求无参数，无抛出异常</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function">String <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">author</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用 default 关键字来给成员指定默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 12</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们定义成员只是使用了String和int 类型，其实注解中成员变量的合法类型可以包括原始的基本类型，String，Class，Annotion,Enumeration.</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    如果注解只有一个成员变量的时候，成员的名称必须取名为value(),在使用的时候我们可以忽略成员名称，和赋值号（=）。</p><p>​    注解类可以没有成员变量，没有成员变量的注解称为标识注解。</p><h5 id="使用上面我们定义的-Description注解"><a href="#使用上面我们定义的-Description注解" class="headerlink" title="使用上面我们定义的@Description注解"></a>使用上面我们定义的@Description注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// age属性可以不用赋值，因为我们定义的时候提供了默认值</span></span><br><span class="line"><span class="meta">@Description</span>(desc = <span class="string">"很可爱"</span>, author = <span class="string">"1"</span>, age = <span class="number">14</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"使用注解"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h3><p>​    通过反射获取类、函数或者成员上运行时注解信息，从而实现动态控制程序运行的逻辑。</p><p>我们可以尝试来解析我们刚刚定义的@Description注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 解析类上的注解</span></span><br><span class="line">    <span class="comment">// 首先我们应该加载我们标记注解的类</span></span><br><span class="line">    Class c = Class.forName(<span class="string">"类路径"</span>);</span><br><span class="line">    <span class="comment">// 判断当前类上面是否添加上@Description注解</span></span><br><span class="line">    <span class="keyword">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class="line">    <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">        <span class="comment">// 拿到注解的实例</span></span><br><span class="line">        Description description = (Description) c.getAnnotation(Description.class);</span><br><span class="line">        System.out.println(description.age());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析方法上的注解</span></span><br><span class="line">    <span class="comment">// 首先遍历所有的方法</span></span><br><span class="line">    Method[] methods = c.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 判断是否有该注解</span></span><br><span class="line">        <span class="keyword">boolean</span> sure = method.isAnnotationPresent(Description.class);</span><br><span class="line">        <span class="keyword">if</span> (sure) &#123;</span><br><span class="line">            Description annotation = method.getAnnotation(Description.class);</span><br><span class="line">            System.out.println(annotation.age());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二中解析方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 获取所有的注解</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="comment">// 判断注解的类型</span></span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Description) &#123;</span><br><span class="line">                Description description = (Description) annotation;</span><br><span class="line">                System.out.println(description.age());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      java注解的使用
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
