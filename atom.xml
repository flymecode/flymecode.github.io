<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白君的博客</title>
  
  <subtitle>凡事必先骑上虎背</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-12T07:32:00.559Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ma Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于CMS的Young GC</title>
    <link href="http://yoursite.com/2019/08/12/%E5%85%B3%E4%BA%8ECMS%E7%9A%84Young-GC/"/>
    <id>http://yoursite.com/2019/08/12/关于CMS的Young-GC/</id>
    <published>2019-08-12T06:16:02.000Z</published>
    <updated>2019-08-12T07:32:00.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>​    CMS 收集器是一种最短回收时间为目标的收集器。在重视服务的相应速度，希望系统停顿时间最短，以给用户最好的体验</p><p>​    CMS 收集器，实现的算法是标记-清除算法，整个过程分为：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>其中初始标记和重新标记需要 STW</p><a id="more"></a><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>​    首先初始标记阶段找出 GC Root 所能直接关联的对象，速度很快，如 Java 栈中引用的对象、方法区中静态变量应用的对象和系统词典中应用的对象并标记，找出老年代对象在 eden 区有引用关系的对象并标记，最后把这些标记的对象复制到 to，在复制过程中还要判断活跃的对象 GC 年领是否已经达到了阈值，如果已经达到阈值，就直接晋升到老年代，YGC 结束之后将 from 和 to 的引用互换。其中大对象直接晋升到老年代，避免了在 eden 区、form、to 之间的复制。在发生 YGC 前，虚拟机会检查老年代最大的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么进行 YGC 是安全的，如果不成立，检查虚拟机是允许担保失败，如果允许会检查老年代最大的连续空间是否大于历次晋升到老年代对象的平均大小或者新生代对象总大小，如果大于则进行 YGC ，如果条件不成立，或者虚拟机不允许空间担保失败，则进行一次 Full GC。</p><h2 id="CMS-收集器缺点"><a href="#CMS-收集器缺点" class="headerlink" title="CMS 收集器缺点"></a>CMS 收集器缺点</h2><ul><li>CMS 收集器对CPU 资源非常敏感</li><li>CMS 收收集器无法处理浮动垃圾，可能出现 “ Concureent Mode Failure” 失败而导致另一次 Full GC 的产生。要是 CMS 在运行期间预留的内存无法满足程序需要，就会出现一次 “ Concureent Mode Failure” ,这个时候虚拟机临时启动 Serial Old 收集器重新来进行老年代的垃圾收集，这样停顿时间就很长了。</li><li>大量空间碎片，空间碎片过多的话会给分配大对象带来麻烦，即使老年代有很大的空间但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC, 为了解决这个问题，CMS 提供了内存碎片整理的参数来设置，或者我进行几次不带碎片整理的 Full GC 之后，随后带一次碎片整理的 Full GC。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CMS-收集器&quot;&gt;&lt;a href=&quot;#CMS-收集器&quot; class=&quot;headerlink&quot; title=&quot;CMS 收集器&quot;&gt;&lt;/a&gt;CMS 收集器&lt;/h2&gt;&lt;p&gt;​    CMS 收集器是一种最短回收时间为目标的收集器。在重视服务的相应速度，希望系统停顿时间最短，以给用户最好的体验&lt;/p&gt;
&lt;p&gt;​    CMS 收集器，实现的算法是标记-清除算法，整个过程分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;重新标记&lt;/li&gt;
&lt;li&gt;并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中初始标记和重新标记需要 STW&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>threadlocal内存泄漏</title>
    <link href="http://yoursite.com/2019/07/12/threadlocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2019/07/12/threadlocal内存泄漏/</id>
    <published>2019-07-12T07:30:29.000Z</published>
    <updated>2019-08-12T08:10:59.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p><img src="/2019/07/12/threadlocal内存泄漏/F352F038-78E0-4AD0-A817-DC807B20E808.png" alt="F352F038-78E0-4AD0-A817-DC807B20E808"></p><a id="more"></a><p><strong>ThreadLocal 原理</strong>：每个 Thread 内维护着一个 ThreadLocalMap，它是一个 Map,这个映射表中 Key 为一个弱引用，就是 ThreadLocal 本身，value 就是我们存储的对象。</p><p>也就是说 ThreadLocal 是一个工具，来维护 ThreadLocalMap 来存取数值，注意图上的虚线，它代表一个弱引用，而弱引用的生命周期只能存活在下一次 GC.</p><h1 id="ThreadLocal-为什么出现内存泄漏"><a href="#ThreadLocal-为什么出现内存泄漏" class="headerlink" title="ThreadLocal 为什么出现内存泄漏"></a>ThreadLocal 为什么出现内存泄漏</h1><p>ThreadLocal 在 ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果 ThreadLocal 没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取 ThreadLocalMap 中的元素是无法通过 null Key 来找到 Value 的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。</p><p>但是JVM团队已经考虑到这样的情况，并做了一些措施来保证 ThreadLocal 尽量不会内存泄漏：在 ThreadLocal 的get()、set()、remove()方法调用的时候会清除掉线程 ThreadLocalMap 中所有 Entry 中 Key 为 null 的 Value，并将整个 Entry 设置为 null，利于下次内存回收。</p><p>来看看ThreadLocal的get()方法底层实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用map.getEntry(this)时，内部会判断key是否为null，继续看map.getEntry(this)源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getEntry方法中，如果Entry中的key发现是null，会继续调用getEntryAfterMiss(key, i, e)方法，其内部回做回收必要的设置，继续看内部源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意k == null这里，继续调用了expungeStaleEntry(i)方法，expunge的意思是擦除，删除的意思，见名知意，在来看expungeStaleEntry方法的内部实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// expunge entry at staleSlot（意思是，删除value，设置为null便于下次回收）</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里，将当前Entry删除后，会继续循环往下检查是否有key为null的节点，如果有则一并删除，防止内存泄漏。但这样也并不能保证 ThreadLoca l不会发生内存泄漏，例如：</p><ul><li>使用 static 的 ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li><li>分配使用了 ThreadLocal 又不再调用get()、set()、remove()方法，那么就会导致内存泄漏。</li></ul><h3 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h3><p>从表面上看，发生内存泄漏，是因为Key使用了弱引用类型。但其实是因为整个Entry的key为null后，没有主动清除value导致。很多文章大多分析ThreadLocal使用了弱引用会导致内存泄漏，但为什么使用弱引用而不是强引用？</p><p>官方文档的说法：</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了处理非常大和生命周期非常长的线程，哈希表使用弱引用作为 key。</p></blockquote><p>下面我们分两种情况讨论：</p><ul><li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li><li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</li></ul><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p><ul><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li></ul><p>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal-原理&quot;&gt;&lt;a href=&quot;#ThreadLocal-原理&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 原理&quot;&gt;&lt;/a&gt;ThreadLocal 原理&lt;/h2&gt;&lt;p&gt;由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/12/threadlocal内存泄漏/F352F038-78E0-4AD0-A817-DC807B20E808.png&quot; alt=&quot;F352F038-78E0-4AD0-A817-DC807B20E808&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://yoursite.com/2019/06/10/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/06/10/mysql索引/</id>
    <published>2019-06-10T08:38:15.000Z</published>
    <updated>2019-08-12T09:00:12.452Z</updated>
    
    <content type="html"><![CDATA[<p>想必大家一提到索引都不陌生，在工作中经常接触到。比如我们一个 SQL 查询比较慢的时候，我们会给某个字段添加索引这样的方法来解决。</p><p>一句话简单的说，索引的出现就是为了提高查询的效率，就像书的目录一样。一本书有 1000 页，如果我们想要快速找到其中某一个知识点，如果不借助目录，我们查询可能会花费比较长的时间，如果我们借助目录的话，可以对我们查找的效率有了很明显的提升。其实对于数据库表而言，索引就是它的“目录”。</p><a id="more"></a><h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>索引的出现是为了提高查询效率，实现索引的方式有很多，比较常见的有哈希表、有序数组、和搜索树。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p> 哈希表是一种 key-value 存储的数据结构，我们只要输入带查找的的数值 key,就可以找到相对应的数值 value。哈希表的思路非常简单，我们把数值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地是多个 key 数值经过哈希函数的换算，会出现同一个数值的情况。处理这种昂情况的一种方法是，拉出一个链表。（这里就跟 JDK 中的 HashMap 中的处理类似 ）</p><p><img src="/2019/06/10/mysql索引/FE4B01D7-65BB-48F2-8E75-D84DDDB97273.png" alt="FE4B01D7-65BB-48F2-8E75-D84DDDB97273"></p><p>图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p><p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了。所以，<strong>哈希表这种结构适用于只有等值查询的场景，</strong>比如 Memcached 及其他一些 NoSQL 引擎。<strong>而有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例。那么我如果使用有序数组的话。</p><h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p><img src="/2019/06/10/mysql索引/WX20190812-165307@2x.png" alt></p><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到 ID_card_X（如果不存在ID_card_X，就找到大于 ID_card_X 的第一个User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2018年某个城市的所有人口信息，这类不会再修改的数据。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="/2019/06/10/mysql索引/WX20190812-165402@2x.png" alt></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>我们可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>nnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p><p><strong>每一个索引在InnoDB里面对应一棵B+树。</strong></p><p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p><p>这个表的建表语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key,</span><br><span class="line">k int not null,</span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB</span><br></pre></td></tr></table></figure><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下.</p><p><img src="/2019/06/10/mysql索引/WX20190812-165415@2x.png" alt></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p><strong>主键索引的叶子节点存的是整行数据</strong>。在InnoDB里，<strong>主键索引也被称为聚簇索引</strong>（clustered index）。</p><p><strong>非主键索引的叶子节点内容是主键的值</strong>。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>索引只能定位到 page, page 内部有个有序数组，通过二分法进行查找具体的数据。</p><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ol><li>只有一个索引；</li><li>该索引必须是唯一索引。</li></ol><p>这就是典型的KV场景。</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p><p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想必大家一提到索引都不陌生，在工作中经常接触到。比如我们一个 SQL 查询比较慢的时候，我们会给某个字段添加索引这样的方法来解决。&lt;/p&gt;
&lt;p&gt;一句话简单的说，索引的出现就是为了提高查询的效率，就像书的目录一样。一本书有 1000 页，如果我们想要快速找到其中某一个知识点，如果不借助目录，我们查询可能会花费比较长的时间，如果我们借助目录的话，可以对我们查找的效率有了很明显的提升。其实对于数据库表而言，索引就是它的“目录”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>count(1) 和 count(*)的区别</title>
    <link href="http://yoursite.com/2019/05/13/count-1-%E5%92%8Ccount-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/13/count-1-和count-的区别/</id>
    <published>2019-05-13T09:32:19.000Z</published>
    <updated>2019-08-11T14:54:15.259Z</updated>
    
    <content type="html"><![CDATA[<p>Count 是一种简单的聚合函数，一般也是我们第一个开始学习的聚合函数，那么他们之间究竟有什么区别呢？</p><p>有人说 count(1) 和 count(*) 他们之间有区别，而有的人说他们之间没有区别那么他们之间到底有没有区别呢？</p><a id="more"></a><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>count(1) 和 count(*) 之间没有区别，因为 count(*) 、count(1) 都不会去空值。单count(列名) 就有区别了，因为 count(列名) 回去过滤控制。</p><h2 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h2><p>他们之间根据不同情况会有些许区别，MySQL会对count（*）做优化。</p><ol><li>如果列为主键，count(列名)效率优于count(1) </li><li>如果列不为主键，count(1)效率优于count(列名)  </li><li>如果表中存在主键，count(主键列名)效率最优  </li><li>如果表中只有一列，则count(*)效率最优  </li><li>如果表有多列，且不存在主键，则count(1)效率优于count(*)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Count 是一种简单的聚合函数，一般也是我们第一个开始学习的聚合函数，那么他们之间究竟有什么区别呢？&lt;/p&gt;
&lt;p&gt;有人说 count(1) 和 count(*) 他们之间有区别，而有的人说他们之间没有区别那么他们之间到底有没有区别呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://yoursite.com/2019/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/13/数据库优化/</id>
    <published>2019-05-13T09:15:32.000Z</published>
    <updated>2019-08-11T15:11:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>数据库是我们开发中会经常使用到，那我们今天来聊一下在数据库方面所发生的问题，今天我主要学习了一下这个三个方面的知识，来给大家分享一下。</p><ol><li>库表设计 ？</li><li>慢 SQL 问题 ？</li><li>误操作、程序 bug 时怎么办 ？</li></ol><a id="more"></a><h2 id="一、库表设计"><a href="#一、库表设计" class="headerlink" title="一、库表设计"></a>一、库表设计</h2><h3 id="1-1-引擎的选择"><a href="#1-1-引擎的选择" class="headerlink" title="1.1 引擎的选择"></a>1.1 引擎的选择</h3><p>在 mysql 5.1 中，引入了新的插件式存储引擎体系结构，允许将存储引擎加载到正在运新的 mysql 服务器中。使用 mysql 插件式存储引擎体系结构，允许数据库专业人员或者设计库表的软件开发人员为特定的应用需求选择专门的存储引擎，完全不需要管理任何特殊的应用编码要求，也无需考虑所有的底层实施细节。因此，尽管不同的存储引擎具有不同的能力，应用程序是与之分离的。此外，使用者可以在服务器、数据库和表格三个层级中存储引擎，提供了极大的灵活性。</p><p>mysql 常用的存储引擎包括 MYISAM、Innodb 和 Memory，其中各自的特点如下：</p><ol><li>MYISAM : 全表锁，拥有较高的执行速度，一个写请求请阻塞另外相同表格的所有读写请求，并发性能差，占用空间相对较小，mysql 5.5 及以下仅 MYISAM 支持全文索引，不支持事务。</li><li>Innodb：行级锁（SQL 都走索引查询），并发能力相对强，占用空间是 MYISAM 的 2.5 倍，不支持全文索引（5.6 开始支持），支持事务。</li><li>Memory : 全表锁，存储在内存当中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重启时会丢失。</li></ol><blockquote><p>基于以上特性，建议绝大部份都设置为 innodb 引擎，特殊的业务再考虑选用 MYISAM 或 Memory ，如全文索引支持或极高的执行效率等。</p></blockquote><h3 id="1-2-分表的方法"><a href="#1-2-分表的方法" class="headerlink" title="1.2 分表的方法"></a>1.2 分表的方法</h3><p>数据库表使用过程中，为了减小数据库服务器的负担、缩短查询时间，常常会考虑做分表设计。分表分两种，一种是纵向分表（将本来可以在同一个表的内容，人为划分存储在为多个不同结构的表）和横向分表（把大的表结构，横向切割为同样结构的不同表）。</p><p>其中，纵向分表常见的方式有根据活跃度分表、根据重要性分表等。其主要解决问题如下：</p><ol><li>表与表之间资源争用问题；</li><li>锁争用机率小；</li><li>实现核心与非核心的分级存储，如UDB登陆库拆分成一级二级三级库；</li><li>解决了数据库同步压力问题。</li></ol><p>横向分表是指根据某些特定的规则来划分大数据量表，如根据时间分表。其主要解决问题如下：</p><ol><li>单表过大造成的性能问题；</li><li>单表过大造成的单服务器空间问题。</li></ol><h3 id="1-3-索引问题"><a href="#1-3-索引问题" class="headerlink" title="1.3 索引问题"></a><strong>1.3 索引问题</strong></h3><p>索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于更快地获取信息。 mysql 有四种不同的索引类型：</p><ol><li><ol><li>主键索此 ( PRIMARY )</li><li>唯一索引 ( UNIQUE )</li><li>普通索引 ( INDEX )</li><li>全文索引（FULLTEXT , MYISAM 及 mysql 5.6 以上的 Innodb ）</li></ol></li></ol><p>建立索引的目的是加快对表中记录的查找或排序，索引也并非越多越好，因为创建索引是要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间维护索引。</p><p>在设计表或索引时，常出现以下几个问题：</p><ol><li>少建索引或不建索引。这个问题最突出，建议建表时 DBA 可以一起协助把关</li><li>索引滥用。滥用索引将导致写请求变慢，拖慢整体数据库的响应速度（5.5 以下的 mysql 只能用到一个索引)。</li><li>从不考虑联合索引。实际上联合索引的效率往往要比单列索引的效率更高。</li><li>非最优列选择。低选择性的字段不适合建单列索引，如 status 类型的字段。</li></ol><h2 id="二、慢-SQL-问题"><a href="#二、慢-SQL-问题" class="headerlink" title="二、慢 SQL 问题"></a>二、慢 SQL 问题</h2><h3 id="2-1-导致慢-SQL-的原因"><a href="#2-1-导致慢-SQL-的原因" class="headerlink" title="2.1 导致慢 SQL 的原因"></a><strong>2.1 导致慢 SQL 的原因</strong></h3><p>在遇到慢 SQL 情况时，不能简单的把原因归结为 SQL 编写问题(虽然这是最常见的因素)，实际上导致慢 SQL 有很多因素，甚至包括硬件和 mysql 本身的 bug。根据出现的概率从大到小，罗列如下：</p><ol><li>SQL编写问题</li><li>锁</li><li>业务实例相互干绕对 IO/CPU 资源争用</li><li>服务器硬件</li><li>MYSQL BUG</li></ol><h3 id="2-2-由-SQL-编写导致的慢-SQL-优化"><a href="#2-2-由-SQL-编写导致的慢-SQL-优化" class="headerlink" title="2.2 由 SQL 编写导致的慢 SQL 优化"></a><strong>2.2 由 SQL 编写导致的慢 SQL 优化</strong></h3><p>针对SQL编写导致的慢 SQL，优化起来还是相对比较方便的。正如上一节提到的正确的使用索引能加快查询速度，那么我们在编写 SQL 时就需要注意与索引相关的规则：</p><ol><li>字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；</li><li>mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；</li><li>不要在字段前面加减运算；</li><li>字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；</li><li>like % 在前面用不到索引；</li><li>根据联合索引的第二个及以后的字段单独查询用不到索引；</li><li>不要使用 select *；</li><li>排序请尽量使用升序 ;</li><li>or 的查询尽量用 union 代替 （Innodb）；</li><li>复合索引高选择性的字段排在前面；</li><li>order by / group by 字段包括在索引当中减少排序，效率会更高。</li></ol><p>除了上述索引使用规则外，SQL 编写时还需要特别注意一下几点：</p><ol><li>尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；</li><li>分页语句 limit 的问题；</li><li>删除表所有记录请用 truncate，不要用 delete；</li><li>不让 mysql 干多余的事情，如计算；</li><li>输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；</li><li>在 Innodb上用 select count(*)，因为 Innodb 会存储统计信息；</li><li>慎用 Oder by rand()。</li></ol><h2 id="三、分析诊断工具"><a href="#三、分析诊断工具" class="headerlink" title="三、分析诊断工具"></a><strong>三、分析诊断工具</strong></h2><p>在日常开发工作中，我们可以做一些工作达到预防慢 SQL 问题，比如在上线前预先用诊断工具对 SQL 进行分析。常用的工具有：</p><ol><li>mysqldumpslow</li><li>mysql profile</li><li>mysql explain</li></ol><p>具体使用及分析方法在此就不赘述，网上有丰富的资源可以参考。</p><h2 id="四、误操作、程序-bug-时怎么办"><a href="#四、误操作、程序-bug-时怎么办" class="headerlink" title="四、误操作、程序 bug 时怎么办"></a><strong>四、误操作、程序 bug 时怎么办</strong></h2><p>当你发现误操作或程序 bug 导致线上数据被误删或误改动时，一定不能慌乱，应及时与 DBA 联系，第一时间进行数据恢复（严重时直接停止服务），尽可能减少影响和损失。对于重要数据（如资金）的操作，在开发时一定要反复进行测试，确保没有问题后再上线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库是我们开发中会经常使用到，那我们今天来聊一下在数据库方面所发生的问题，今天我主要学习了一下这个三个方面的知识，来给大家分享一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;库表设计 ？&lt;/li&gt;
&lt;li&gt;慢 SQL 问题 ？&lt;/li&gt;
&lt;li&gt;误操作、程序 bug 时怎么办 ？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化</title>
    <link href="http://yoursite.com/2019/05/12/JVM%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/12/JVM优化/</id>
    <published>2019-05-12T03:42:43.000Z</published>
    <updated>2019-08-11T05:25:14.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM运行参数"><a href="#JVM运行参数" class="headerlink" title="JVM运行参数"></a>JVM运行参数</h2><h3 id="三种参数类型"><a href="#三种参数类型" class="headerlink" title="三种参数类型"></a>三种参数类型</h3><ul><li><p>标准参数</p><ul><li>-help</li><li>-version</li><li>-D 设置程序运行的参数</li><li>-server  使用并行的垃圾收集器，启动慢，运行快</li><li>-client 使用串行的垃圾收集器，启动快，运行慢</li></ul></li><li><p>-X参数（非标准参数）</p><ul><li>-Xint </li><li>-Xcomp</li><li>-Xmixed</li><li>-Xms 堆的初始大小</li><li>-Xmx 堆的最大大小</li></ul></li><li><p>-XX 参数（使用率较高）</p><ul><li>-XX: newSize</li><li>-XX:+UseSerialGC</li><li>-XX:newRadio</li><li>-XX:+PrintFlagsFinal 输出JVM运行时的参数</li></ul></li></ul><p><img src="/2019/05/12/JVM优化/E:/Git\TTMS\MX-Notes\image\1557634794531.png" alt="1557634794531"></p><p>jps</p><p>jinfo -flags 进程id</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM运行参数&quot;&gt;&lt;a href=&quot;#JVM运行参数&quot; class=&quot;headerlink&quot; title=&quot;JVM运行参数&quot;&gt;&lt;/a&gt;JVM运行参数&lt;/h2&gt;&lt;h3 id=&quot;三种参数类型&quot;&gt;&lt;a href=&quot;#三种参数类型&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>一次完整的http请求过程</title>
    <link href="http://yoursite.com/2019/05/11/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/11/一次完整的http请求过程/</id>
    <published>2019-05-11T13:55:48.000Z</published>
    <updated>2019-08-11T05:25:14.657Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器上输入 <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 然后回车，回车这一瞬间到底发生了什么？</p><p>首先是域名解析，然后是建立 TCP 三次握手，建立 TCP 连接之后发起 HTTP 请求，服务器响应请求，浏览器获得 HTML 代码，浏览器解析 HTML 代码，并请求 HTML 代码中的资源，浏览器开始对页面进行渲染将页面呈现给用户。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><ul><li>首先浏览器会搜索自身的 DNS 缓存，如果有该条目，如果没有过期则返回。</li><li>如果浏览器缓存中没有找到，此时会查找操作系统本地 DNS 缓存，查看方式 ipconfig/displaydns。</li><li>如果操作系统的 DNS 缓存没有查找到则开始读取 host 文件的缓存，如果有则解析成功。</li><li>如果 host 文件中没有找到则计算机发起一个 DNS 的系统调用，向本地配置的 DNS 服务器发送一个域名解析的请求，运营商的 DNS 服务器首先会查找本地缓存，如果有则解析成功，如果没有则 DNS 服务器会代替我们浏览器发起迭代的请求，首先想根域名，然后从右向左，逐一进行请求。</li></ul><p>浏览器拿到 index.html 文件后，就开始解析其中的 html 代码，遇到 js/css/image 等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上 keep-alive 特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p><p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个 http 请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在浏览器上输入 &lt;a href=&quot;http://www.xxx.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.xxx.com&lt;/a&gt; 然后回车，回车这一瞬间到底发生了什么？&lt;/p&gt;
&lt;p&gt;首先是域名解析，然后是建立 TCP 三次握手，
      
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>事务的隔离级别和传播机制</title>
    <link href="http://yoursite.com/2019/05/11/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/11/事务的隔离级别和传播机制/</id>
    <published>2019-05-11T13:54:43.000Z</published>
    <updated>2019-08-11T05:25:14.657Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://yoursite.com/2019/05/10/redis/"/>
    <id>http://yoursite.com/2019/05/10/redis/</id>
    <published>2019-05-10T00:14:55.000Z</published>
    <updated>2019-08-11T05:25:14.656Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进程和线程</title>
    <link href="http://yoursite.com/2019/05/10/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/10/进程和线程/</id>
    <published>2019-05-09T16:23:53.000Z</published>
    <updated>2019-08-11T05:25:14.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程的切换过程"><a href="#进程的切换过程" class="headerlink" title="进程的切换过程"></a>进程的切换过程</h2><p>用户态发生系统调用进入内核态</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>进程是资源分配的最小单位，线程是 CUP 调度的最小单位。</li><li>所有与进程相关的资源都被记录在 PCB 中。</li><li>进程是抢占处理机的调度单位，线程属于某个进程，共享其资源</li><li>线程只由堆栈寄存器、程序计数器和 TCB 组成</li><li>线程不能看做独立的应用，而进程可看做独立应用</li><li>进程有独立的地址空间，相互影响，线程只是进程的不同执行路径</li><li>线程没有独立的地址空间，多进程的程序比多线程程序健壮</li><li>进程的切换比线程切换开销大</li></ul><h2 id="进程的通信实现"><a href="#进程的通信实现" class="headerlink" title="进程的通信实现"></a>进程的通信实现</h2><ul><li><p>管道</p><p>半双工，速度慢，容量有限，只能父子间通信</p></li><li><p>命名管道</p></li><li><p>FIFO</p><p>任何进程间都能通信，速度慢</p></li><li><p>信号量</p><p>不能传递复杂消息，只能同步</p></li><li><p>共享内存</p><p>能够很容易控制容量，速度快</p></li></ul><h2 id="线程的通信实现"><a href="#线程的通信实现" class="headerlink" title="线程的通信实现"></a>线程的通信实现</h2><ul><li><p><strong>wait/notify机制</strong></p><p><strong>wait : </strong>让当前线程释放对象锁，并进入阻塞状态。</p><p><strong>notify :</strong>唤醒一个正在等待相应对象锁的线程，使其进入同步队列，以便在当前线程释放锁后竞争所，进而得到 CPU 的执行。在执行 notify 方法之后，当前线程并不能马上释放锁对象，呈 wait 状态的线程也并不能马上获取该对象锁，只有执行 notify 方法的线程退出 synchronized 代码块/方法后,当前线程才会释放锁，而呈 wait 状态的线程才会去竞争锁。</p><p><strong>notityAll :</strong>唤醒所有正在等待相应对象锁的线程。</p></li><li><p><strong>Condition</strong></p><p><strong>await</strong></p><p><strong>singal</strong></p><p><strong>singalAll</strong></p></li><li><p><strong>生产者消费者模型</strong></p></li><li><p><strong>管道 PipedOutStream/PipedInputStream</strong></p></li><li><p><strong>Join</strong></p><p>假如在main线程中调用thread.join方法，则main线程会等待thread线程执行完毕或者等待一定的时间。join 是调用 wait 方法实现，同样会让宿主线程交出 CPU 的执行权限，会让线程释放对一个对象持有的锁，如果调用了 join 方法，必须捕获 InterruptedException 异常或者将该异常向上层抛出。</p></li></ul>]]></content>
    
    <summary type="html">
    
      学习关于进程和线程的相关知识点
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Http 和 Https的区别</title>
    <link href="http://yoursite.com/2019/05/09/Http-%E5%92%8C-Https%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/09/Http-和-Https的区别/</id>
    <published>2019-05-09T15:56:33.000Z</published>
    <updated>2019-08-11T15:19:16.021Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们经常使用到 http 协议和 https 协议，那他们之间有什么区别呢？</p><p>他们的基本概念是什么呢？我们今天来学习一下。</p><a id="more"></a><h2 id="详细解析-HTTP-与-HTTPS-的区别"><a href="#详细解析-HTTP-与-HTTPS-的区别" class="headerlink" title="详细解析 HTTP 与 HTTPS 的区别"></a>详细解析 HTTP 与 HTTPS 的区别</h2><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在HTTP的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h2 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a><strong>HTTP和HTTPS的基本概念</strong></h2><p><strong>HTTP</strong>：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p><strong>HTTPS</strong>：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP下 加入SSL层，HTTPS 的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p><strong>HTTPS 协议的主要作用可以分为两种</strong>：</p><ul><li>建立一个信息安全通道，来保证数据传输的安全。</li><li>确认网站的真实性。</li></ul><h2 id="HTTP与HTTPS有什么区别"><a href="#HTTP与HTTPS有什么区别" class="headerlink" title="HTTP与HTTPS有什么区别"></a><strong>HTTP与HTTPS有什么区别</strong></h2><ul><li>https 协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http 的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</li></ul><h2 id="数据传输安全的意思？"><a href="#数据传输安全的意思？" class="headerlink" title="数据传输安全的意思？"></a>数据传输安全的意思？</h2><ul><li>客户端和服务器之间的通信只能又自己看得懂，第三方拿到数据也看不懂这些信息的真实含义。</li><li>第三方虽然看不懂，但是可以对数据篡改，因此客户端和服务端必须有能力判断数据是否被修改过。</li><li>客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。</li></ul><h2 id="怎么加密信息？"><a href="#怎么加密信息？" class="headerlink" title="怎么加密信息？"></a>怎么加密信息？</h2><p>使用对称秘钥和非对称秘钥进行加密，对称秘钥是加密和解密都用相同的秘钥进行。非对称秘钥有两个秘钥，一个公钥和一个私钥。公钥加密的内容只有通过私钥才能解密，私钥加密的内容只有通过公钥进行解密。使用对称加密一般比非对称加密快得多，对服务器的运算压力也小。</p><h2 id="对称秘钥怎么传输"><a href="#对称秘钥怎么传输" class="headerlink" title="对称秘钥怎么传输?"></a>对称秘钥怎么传输?</h2><p>服务器明文传输对称秘钥是不安去的，如果监听者拿到对称秘钥，以后的通信内容就被破解了。所以不能明文传输对称秘钥，而且不能用一个新的对称秘钥来加密原来的对称秘钥，否则新的对称秘钥同样无法传输，就是鸡生蛋，蛋生鸡的驳论。</p><p>这里我们采用非对称加密的方式，非对称加密的特性决定了服务器用私钥加密的内容并不是真正的加密，因为公钥所有人都有，所以服务器的密文能被所有人解析，但是私钥只掌握在服务器手上，这就带来了两个好的优势：</p><ul><li>服务器下发的内容不能被伪造，因为别人都没有私钥，只有服务器有，所以无法加密。强行加密的后果是客户端使用公钥都无法完成解密。</li><li>任何人用公钥加密的内容都是绝对安全的，因为私钥只有服务端有，也就是只有真正的服务器可以看到加密的原文</li></ul><p>所以传输对称秘钥的问题就迎刃而解了：秘钥不是由服务器下发的，而是由客户端生成并主动高数服务器。所以当引入非对称加密后，HTTPS的握手流程依然是两部，不过细节略有变化：</p><p>​    客户端：你好，我要发起一个HTTPS的请求，这是我的秘钥（用公钥加密后的）</p><p>​    服务端：好的，我知道你的秘钥了，后续就用它来传输。</p><h2 id="公钥怎么传输？"><a href="#公钥怎么传输？" class="headerlink" title="公钥怎么传输？"></a>公钥怎么传输？</h2><p>对公钥进行加密，每一个HTTPS服务器都必须去专门的证书机构注册一个证书，证书中存储了用权威机构私钥加密的公钥。这样客户端用权威机构的公钥解密就可以了。</p><p>现在HTTPS协议握手阶段变成四步：</p><ol><li>客户端：你好，我要发起一个HTTPS请求，请给我公钥</li><li>服务器：好的，这是我的证书，里面有加密后的公钥</li><li>客户端：解密成功以后告诉服务器，这是我的对称秘钥</li><li>服务器：好的，我知道了你的秘钥了，后续就用它来传输吧。</li></ol><h2 id="那么权威机构的公钥怎么传输呢？"><a href="#那么权威机构的公钥怎么传输呢？" class="headerlink" title="那么权威机构的公钥怎么传输呢？"></a>那么权威机构的公钥怎么传输呢？</h2><p>这个公钥不用传输，会直接内置在各大操作系统或者浏览器的出厂设置里。之所以不把每个服务器的公钥内置在电脑里，一方面服务器太多，存不过来。另一方面操作系统也不信任你，凭什么你说你这个就是百度的证书呢。所以各个公司先去权威机构认证，申请证书，然后操作系统只会存储权威机构的公钥。因为权威机构数量有限，所以操作系统厂商相对来说容易管理。如果这个权威机构不够权威，胡乱发证书，就会取消他的资格，比如可怜的沃通。</p><h2 id="怎么知道证书没有被篡改？"><a href="#怎么知道证书没有被篡改？" class="headerlink" title="怎么知道证书没有被篡改？"></a>怎么知道证书没有被篡改？</h2><p>将信息哈希值随着信息一起传递。为了保证证书没有篡改，我们可以在传递证书的同时传递的哈希值。由于第三者无法解析数据，只能胡乱改，那么修改后的数据在解密后，就不能通过哈希。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中我们经常使用到 http 协议和 https 协议，那他们之间有什么区别呢？&lt;/p&gt;
&lt;p&gt;他们的基本概念是什么呢？我们今天来学习一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>线程池使用总结</title>
    <link href="http://yoursite.com/2019/05/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/09/线程池使用总结/</id>
    <published>2019-05-09T14:00:43.000Z</published>
    <updated>2019-08-11T05:25:14.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><img src="/2019/05/09/线程池使用总结/1557327261076.png" alt></p><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><p><img src="/2019/05/09/线程池使用总结/1557327546254.png" alt></p><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p><img src="/2019/05/09/线程池使用总结/1557327451978.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程池的好处&quot;&gt;&lt;a href=&quot;#线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;线程池的好处&quot;&gt;&lt;/a&gt;线程池的好处&lt;/h2&gt;&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池
      
    
    </summary>
    
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>spring回滚事务的处理思路</title>
    <link href="http://yoursite.com/2019/05/09/spring%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/05/09/spring回滚事务的处理思路/</id>
    <published>2019-05-09T13:48:02.000Z</published>
    <updated>2019-08-11T15:16:05.197Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用中经常使用 spring，但是我们是否真正的理解当事务发生回滚的时候spring 是怎么给我处理的吗？是否会回滚呢，现在让我们来一起看看吧。</p><a id="more"></a><h2 id="spring-try-…-catch-事务不回滚的处理思路"><a href="#spring-try-…-catch-事务不回滚的处理思路" class="headerlink" title="spring try {…} catch {} 事务不回滚的处理思路"></a>spring try {…} catch {} 事务不回滚的处理思路</h2><p>当希望在某个方法中添加事务时，我们常常在方法头上添加@Transactional注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易让人忽略的是：方法上未加任何属性的 @Transactional 注解只能在抛出 RuntimeException 或者 Error 时才会触发事务的回滚，常见的 非RuntimeException 是不会触发事务的回滚的。</p><p>如果要在抛出 非RuntimeException时也触发回滚机制，需要我们在注解上添加 rollbackFor = { Exception.class }属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = &#123; Exception.class &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面事务回滚的前提是添加 @Transactional 注解的方法中不含有 try{…}catch{…} 异常，使得程序运行过程中出现异常能顺利抛出，从而触发事务回滚。</p><p>在实际开发中，我们往往需要在方法中进行异常的捕获，从而对异常进行判断，为客户端返回提示信息。但是此时由于异常的被捕获，导致事务的回滚没有被触发，导致事务的失败。</p><p>下面提供几种解决方法：</p><h3 id="1-使用-Transactional注解，抛出-Transactional注解默认识别的RuntimeException"><a href="#1-使用-Transactional注解，抛出-Transactional注解默认识别的RuntimeException" class="headerlink" title="1. 使用@Transactional注解，抛出@Transactional注解默认识别的RuntimeException"></a>1. 使用@Transactional注解，抛出@Transactional注解默认识别的RuntimeException</h3><p>方法上使用@Transactional注解，在捕获到异常时在catch语句中抛出RuntimeException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理返回消息</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-Transactional-rollbackFor-Exception-class-，抛出捕获的非RuntimeException异常"><a href="#2-使用-Transactional-rollbackFor-Exception-class-，抛出捕获的非RuntimeException异常" class="headerlink" title="2. 使用@Transactional(rollbackFor = { Exception.class })，抛出捕获的非RuntimeException异常"></a>2. 使用@Transactional(rollbackFor = { Exception.class })，抛出捕获的非RuntimeException异常</h3><p>方法上使用@Transactional(rollbackFor = { Exception.class })注解声明事务回滚级别，在捕获到异常时在catch语句中直接抛出所捕获的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = &#123; Exception.class &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理返回消息</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-手动回滚"><a href="#3-手动回滚" class="headerlink" title="3. 手动回滚"></a>3. 手动回滚</h3><p>上面两个在catch{…}中抛出异常的方法都有个不足之处，就是不能在catch{…}中存在return子句，所以设置手动回滚，当捕获到异常时，手动回滚，同时返回前台提示信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Payment <span class="title">paymentJson</span><span class="params">(@RequestBody PaymentRequestInfo entity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="comment">// 手动回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用中经常使用 spring，但是我们是否真正的理解当事务发生回滚的时候spring 是怎么给我处理的吗？是否会回滚呢，现在让我们来一起看看吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见问题总结</title>
    <link href="http://yoursite.com/2019/05/09/MQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/09/MQ常见问题/</id>
    <published>2019-05-09T12:12:15.000Z</published>
    <updated>2019-08-11T05:25:14.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ常见问题"><a href="#MQ常见问题" class="headerlink" title="MQ常见问题"></a>MQ常见问题</h1><p>消息队列核心解决的问题主要是：异步、解耦、消息切峰。异步、解耦、消峰填谷这是消息队列最大的优点，除了这些消息队列还可以会解决一些我们特殊业务场景的问题。但是缺点主要在于系统的可用性、复杂性、一致性问题，引入消息队列后，需要考虑MQ的可用性，万一MQ崩溃了岂不是要爆炸？而且复杂性明显提高了，需要考虑一些消息队列的常见问题和解决方案，还有就是一致性问题，一条消息由多个消费者消费，万一有一个消费者消费失败了，就会导致数据不一致。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul><li>单机吞吐量：万级别</li><li>失效性：微秒级别</li><li>可用性：基于主从架构</li></ul><p>RabbitMQ现在使用的较为多一些，社区活跃度也很高，功能也很强大，官方还提供了管理的web界面，性能也很好，但是RabbitMQ性能好的主要原因是因为使用erlang语言开发的，erlang语言貌似天生性能好，但对于我们java开发者来说，源码基本看不懂，更别提深入的研究了，不过spring推出了rabbit的支持，貌似还比较好用，比自己去封装实现并且去处理一些问题的要好多了。</p><h2 id="RabbitMQ-模式"><a href="#RabbitMQ-模式" class="headerlink" title="RabbitMQ 模式"></a>RabbitMQ 模式</h2><ul><li><p>单机模式</p><p>单机模式通常是用来进行测试和开发的场景，测试一般是否能正确的处理数据，线上环境没人去用单机模式，风险大。</p></li><li><p>普通集群模式</p><p>普通集群模式就是启动多个 RabbitMQ 实例，在你创建queue只会放在一个 RabbitMQ上，但是每个实例都同步 queue 的元数据，在消费的时候，如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据，后者有数据拉取的开销，前者导致单实例性能瓶颈。而且如果那个放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作</p></li><li><p>镜像集群模式</p><p>镜像集群模式是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</p><p>优点在于你任何一个实例宕机了，没事儿，别的实例都可以用。缺点在于性能开销太大和扩展性很低，同步所有实例，这会导致网络带宽和压力很重，而且扩展性很低，每增加一个实例都会去包含已有的queue的所有数据，并没有办法线性扩展queue。</p><p>开启镜像集群模式可以去RabbitMQ的管理控制台去增加一个策略，指定要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p></li></ul><h2 id="如何保证消息的幂等性"><a href="#如何保证消息的幂等性" class="headerlink" title="如何保证消息的幂等性"></a>如何保证消息的幂等性</h2><p>消息重复消费的原因主要是在与回馈机制，在某些场景中我们采用回馈机制不同，原因也不同，比如消费者消费完成消息之后回复 ack ，但是刚消费完成还没有来的及提交，系统就重新启动。这时重新启动就会pull 消息的时候没有提高 ack ，消息还是上次的消息。</p><p>那么如何怎么来保证消息消费的幂等性呢？实际上我们只要保证多条相同的数据过来的时候只处理一条或者说多条处理和处理一条造成的结果相同即可，但是具体怎么做要根据业务需求来定，例如入库消息，先查一下消息是否已经入库啊或者说搞个唯一约束啊什么的，还有一些是天生保证幂等性就根本不用去管，例如redis就是天然幂等性。</p><p>还有一个问题，消费者消费消息的时候在某些场景下要放过消费不了的消息，遇到消费不了的消息通过日志记录一下或者搞个什么措施以后再来处理，但是一定要放过消息，因为在某些场景下例如spring-rabbitmq的默认回馈策略是出现异常就没有提交ack，导致了一直在重发那条消费异常的消息，而且一直还消费不了，这就尴尬了，后果你会懂的。</p><h2 id="消息遗漏"><a href="#消息遗漏" class="headerlink" title="消息遗漏"></a>消息遗漏</h2><p><strong>1）生产者弄丢了数据</strong><br>　　生产者将数据发送到RabbitMQ的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。此时可以选择用RabbitMQ提供的事务功能，就是生产者发送数据之前开启RabbitMQ事务（channel.txSelect），然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，RabbitMQ事务机制一搞，基本上吞吐量会下来，因为太耗性能。</p><p>　　所以一般来说，如果你要确保说写RabbitMQ的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了RabbitMQ中，RabbitMQ会给你回传一个ack消息，告诉你说这个消息ok了。如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>　　事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息RabbitMQ接收了之后会异步回调你一个接口通知你这个消息接收到了。</p><p>　　所以一般在生产者这块避免数据丢失，都是用confirm机制的。</p><p><strong>（2）RabbitMQ弄丢了数据</strong></p><p>　　就是RabbitMQ自己弄丢了数据，这个你必须开启RabbitMQ的持久化，就是消息写入之后会持久化到磁盘，哪怕是RabbitMQ自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p><h5 id="设置持久化有两个步骤"><a href="#设置持久化有两个步骤" class="headerlink" title="设置持久化有两个步骤"></a>设置持久化有两个步骤</h5><p>第一个是创建queue的时候将其设置为持久化的，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里的数据；</p><p>第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，RabbitMQ哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p><p>而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</p><p>哪怕是你给RabbitMQ开启了持久化机制，也有一种可能，就是这个消息写到了RabbitMQ中，但是还没来得及持久化到磁盘上，结果不巧，此时RabbitMQ挂了，就会导致内存里的一点点数据会丢失。</p><p><strong>（3）消费端弄丢了数据</strong></p><p>　　RabbitMQ如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ认为你都消费了，这数据就丢了。</p><p>　　这个时候得用RabbitMQ提供的ack机制，简单来说，就是你关闭RabbitMQ自动ack，可以通过一个api来调用就行，然后每次你自己代码里确保处理完的时候，在程序里ack一把。这样的话，如果你还没处理完，不就没有ack？那RabbitMQ就认为你还没处理完，这个时候RabbitMQ会把这个消费分配给别的consumer去处理，消息是不会丢的。</p><p>在发送消息的时候，接受时记录 DB 日志，定时轮询 DB 日志，查明那些发送的消息没有成功消费，启动重新发送消息机制。</p><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p><strong>场景： 比如下单操作，下单成功后，会发布创建订单和减库存的消息，但扣库存消息执行会先于创建订单的消息，也就说前者执行成功之后，才能执行后者。</strong></p><p>MQ 层面支持消息的顺序处理开销太大了，为了极少量的需求，增加了整体上的复杂性。应该尽可能的在应用层面进行处理。</p><p>解决方式如下：</p><ol><li>同步执行，当一个消息执行之后，再发送下一个消息。</li><li>rabbitmq：拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。</li></ol><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><p>如果消费端接受到两个一样的消息，应该如何处理呢？</p><ol><li>消费端处理消息的业务逻辑应该保持幂等性。</li><li>保证每条消息都有唯一标号，首先检查执行成功的日志中是否存有该消息的 ID 如果没有则执行，如果已经存在则丢弃消息。如果在消息系统中实现，会对消息系统的吞吐量造成影响。所以还是在业务端进行去重处理。</li></ol><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p> 具体来说，就是把消息的发送分成了2个阶段：Prepare阶段和确认阶段。</p><p>具体来说，上面的2个步骤，被分解成3个步骤：<br>(1) 发送Prepared消息<br>(2) update DB<br>(3) 根据update DB结果成功或失败，Confirm 或者取消 Prepared 消息。</p><p>可能有人会问了，前2步执行成功了，最后1步失败了怎么办？这里就涉及到了RocketMQ的关键点：RabbitMQ 会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？</p><h2 id="消息阻塞"><a href="#消息阻塞" class="headerlink" title="消息阻塞"></a>消息阻塞</h2><p><strong>上千万条消息在 mq 里积压了几个小时了还没解决</strong> </p><p>紧急扩容</p><p>1）先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉<br>2）新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量<br>3）然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<br>消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue<br>4）接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据<br>5）这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据<br>6）等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</p><h2 id="消息队列过期失效问题"><a href="#消息队列过期失效问题" class="headerlink" title="消息队列过期失效问题"></a>消息队列过期失效问题</h2><p>　假设你用的是rabbitmq，rabbitmq是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，这个数据就没了。晚上12点以后，用户都睡觉了。</p><p>　　这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把白天丢的数据给他补回来。也只能是这样了。</p><p>　　假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次。</p><h2 id="消息队列满"><a href="#消息队列满" class="headerlink" title="消息队列满"></a>消息队列满</h2><p>丢弃，晚上补数据</p>]]></content>
    
    <summary type="html">
    
      MQ 生产上遇到的一些问题和解决办法进行总结
    
    </summary>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://yoursite.com/2019/05/09/network/"/>
    <id>http://yoursite.com/2019/05/09/network/</id>
    <published>2019-05-09T11:44:25.000Z</published>
    <updated>2019-08-11T05:25:14.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层的任务就是通过应用进程间的交互来完成特定网络应用，应用层协议定义的的是应用进程间的通信和交互规则，对于不同的网路需要不同的应用层协议。我们把应用层交互的数据叫做报文。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>网络层只是把分组发送到目的主机，但是真正通信并不是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来好像在两个传输实体之间有一条端到端的逻辑通信信道。</p><h3 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h3><ul><li>用户数据协议 UDP 是无连接的，尽最大的可能提供交付，没有拥塞控制，面向报文（对应用层序传输下来的报文即不拆分也不合并，只是添加 UDP 首部），支持一对一，一对多，多对一，多对多的通信。</li><li>传输控制协议 TCP 是面向连接的，提供可靠的交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能点对点的通信。</li></ul><h3 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h3><ul><li><strong>序号：</strong> 用来对字节流进行编号。</li><li><strong>确认号：</strong>期望下次收到的报文段的序号。 </li><li><strong>数据偏移：</strong> 指数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认ACK：</strong> 当 ACK = 1 的确认号字段有效，否则无效，TCP 规定，在连接建立之后所有传输的报文段都必须把 ACK 设置为 1。</li><li><strong>同步SYN：</strong> 在连接建立时用来同步序号。当 SYN = 1，ACK = 0 时表示这是一个连接请求报文段。若对方同意建立连接则响应报文中 SYN = 1，ACK = 1。</li><li><strong>终止FIN：</strong> 用来释放一个连接，当 FIN = 1 的时候，表示报文端已经发送完毕，并要求释放连接。</li><li><strong>窗口：</strong> 窗口作为接收方让发送方设置其发窗口的依据。之所以要有要有这个限制，是因为接受方的数据缓存空间是有限的。</li></ul><h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p><img src="/2019/05/09/network/E:/Git\TTMS\MX-Notes\image\1557411990645.png" alt="1557411990645"></p><p>假设 A 为客户端，B 为服务端</p><ul><li>首先 B 处于监听状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN = 1, ACK = 0,选择一个初始的序号 x </li><li>B 收到请求报文之后，如果同意连接，则向 A 发送连接确认的报文，SYN = 1，ACK = 1,确认号为 x + 1,同时选择一个初始序号 y。</li><li>A 收到 B 的连接确认报文之后，还要向 B 发处确认，ACK = 1, 确认号为 y + 1,序号为 x + 1</li><li>B 收到 A 的确认后，连接建立</li></ul><h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><ul><li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误的打开连接。</li><li>客户端发送的连接请求在网络中滞留，那么会隔很长的时间才能收到服务端发来回来的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的确认连接确认，不进行第三次握手，因此就不会再次打开连接。</li></ul><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p><img src="/2019/05/09/network/E:/Git\TTMS\MX-Notes\image\1557412704769.png" alt="1557412704769"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h4 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a><strong>四次挥手的原因</strong></h4><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在计算机网络进行通信的两个计算机之间可能会经过多个数据链路，可能还要经过多个通信子网，网络层的任务就是选择合适的网络路由和交换节点，确保数据的及时发送。在发送数据的时候把运输层的数据报封装成组和包进行传送，网络层使用的协议是 IP 协议，因此分组也叫数据报。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>将网络层交下来的IP数据组装成帧。在两个相邻节点的链路上传送帧。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。</p>]]></content>
    
    <summary type="html">
    
      对网络层知识点学习总结，对每一层划分，对网络知识整体上有了认知
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java设计笔记</title>
    <link href="http://yoursite.com/2018/11/13/design/"/>
    <id>http://yoursite.com/2018/11/13/design/</id>
    <published>2018-11-12T16:47:01.000Z</published>
    <updated>2019-08-11T05:25:14.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Controller层"><a href="#一、Controller层" class="headerlink" title="一、Controller层"></a>一、Controller层</h4><ul><li>定义每个模块的restful接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user"</span>, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br></pre></td></tr></table></figure><ul><li>只负责控制逻辑与返回响应数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.OK.toString(), HttpStatus.OK);</span><br></pre></td></tr></table></figure><ul><li><p>每个controller添加日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br></pre></td></tr></table></figure></li><li><p>将request请求传递给业务层(service)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = userService.getUserName(Id, request)</span><br></pre></td></tr></table></figure></li><li><p>添加一个Template 和一个响应实体ResponseEntity&lt;&gt;将返回的数据放入模板中，然后将模板封装到响应实体之中，最后将相应实体发送给前端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserTemplate user = userService.getUserById(Id, request);</span><br><span class="line">ResponseEntity&lt;&gt;(user, HttpStatus.OK)</span><br></pre></td></tr></table></figure></li><li><p>针对不同的请求添加不同的注解</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/xxx"</span>) <span class="meta">@PosstMapping</span>(<span class="string">"/xxx"</span>) <span class="meta">@PutMapping</span>(<span class="string">"/xxx"</span>)</span><br></pre></td></tr></table></figure><ul><li>使用@PathVariable(value = “id”) 支持Restful</li><li>使用@RequestParam接受Request中的数据 </li><li>使用数据字典，将常量统一保存到指定的类中进行管理。</li></ul><h4 id="二、Service层"><a href="#二、Service层" class="headerlink" title="二、Service层"></a>二、Service层</h4><ul><li><p>分页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// SearchVo 封装了查询条件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getList</span><span class="params">(SearchVo searchVo, PageInfo pageInfo)</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取总行数</span></span><br><span class="line">    Integer totalSize = userMapper.getUserCount(searchVo);</span><br><span class="line">    <span class="comment">// 增强鲁棒性</span></span><br><span class="line">    <span class="keyword">if</span> (totalSize == <span class="keyword">null</span> || totalSize == <span class="number">0</span>) &#123;</span><br><span class="line">        pageInfo.setTotalSize(<span class="number">0</span>);</span><br><span class="line">        pageInfo.setPageCount(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageInfo.setTotalSize(totalSize);</span><br><span class="line">        pageInfo.setPageCount((<span class="keyword">int</span>) Math.ceil((totalSize * <span class="number">1.0</span>) /         ----(pageInfo.getPageSize() * <span class="number">1.0</span>)));        </span><br><span class="line">        Integer offset = (pageInfo.getPageNo() - <span class="number">1</span>) * pageInfo.getPageSize();</span><br><span class="line">        searchVo.setOffset(offset);</span><br><span class="line">        searchVo.setPageSize(pageInfo.getPageSize());</span><br><span class="line">        <span class="comment">// 查询数据</span></span><br><span class="line">        userList = userMapper.searchUser(searchVo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isEmpty() <span class="comment">//判断是否为空</span></span><br></pre></td></tr></table></figure></li><li><p>事务处理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = &#123;Throwable.class, Exception.class&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果出现异常向上抛出</p></li><li><p>数据的封装</p></li><li>业务的处理</li></ul><h4 id="三、-Mapper层"><a href="#三、-Mapper层" class="headerlink" title="三、 Mapper层"></a>三、 Mapper层</h4><ul><li>定制sql        </li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SelectProvider</span>(type = BookSQLProvider.class, method = <span class="string">"searchBook"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">getDsDashboardCount</span><span class="params">(SearchVo searchBean)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookSQLProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">searchBook</span><span class="params">(SearchVo searchBean)</span> </span>&#123;</span><br><span class="line">        StringBuffer sql = <span class="keyword">new</span> StringBuffer(<span class="keyword">new</span> SQL()&#123;&#123;</span><br><span class="line">            SELECT(<span class="string">"count(1)"</span>);</span><br><span class="line">            FROM(<span class="string">"db_book b, db_person p"</span>);</span><br><span class="line">            WHERE(<span class="string">"b.id = p.id"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(searchBean.getDashboardName()))&#123;</span><br><span class="line">                WHERE(<span class="string">"title like '"</span>+searchBean.getDashboardName()+<span class="string">"%'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(searchBean.getCreator())) &#123;</span><br><span class="line">                WHERE(<span class="string">"creator = #&#123;creator&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString());</span><br><span class="line">        <span class="keyword">return</span> sql.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>CRUD</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"INSERT INTO dp_report_dashboards (title) VALUES (#&#123;title&#125;)"</span>) <span class="comment">// 关键字大写</span></span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys=<span class="keyword">true</span>, keyProperty=<span class="string">"id"</span>) <span class="comment">// 主键自增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createDashboard</span><span class="params">(MetaDashboard dashboard)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="注解-Results"><a href="#注解-Results" class="headerlink" title="注解@Results"></a>注解@Results</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line"><span class="meta">@Result</span>(property = <span class="string">"id"</span>, column = <span class="string">"id"</span>, javaType = Long.class, jdbcType = JdbcType.BIGINT),</span><br><span class="line">    <span class="meta">@Result</span>(property = <span class="string">"book_price"</span>, column = <span class="string">"db_id"</span>, javaType = Long.class, jdbcType = JdbcType.BIGINT),</span><br><span class="line">    <span class="meta">@Result</span>(property = <span class="string">"image"</span>, column = <span class="string">"iamge"</span>, javaType = Image.class,many = <span class="meta">@many</span>(select = <span class="string">"com.mx.mappers.ImageMapper.getImageById"</span>)),</span><br><span class="line"><span class="meta">@Result</span>(</span><br><span class="line">    property = <span class="string">"company_id"</span>, column = <span class="string">"company_id"</span>, javaType = List.class,many = <span class="meta">@Many</span>(select =<span class="string">"com.mx.mappers.CompanyMapper.getInfoById"</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一些设计的技巧
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://yoursite.com/2018/09/27/annotion/"/>
    <id>http://yoursite.com/2018/09/27/annotion/</id>
    <published>2018-09-26T16:47:01.000Z</published>
    <updated>2019-08-11T05:25:14.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><ul><li>@Override，表示当前的方法定义将覆盖超类中的方法。</li><li>@Deprecated，使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。</li><li>@SuppressWarnings，关闭不当编译器警告信息。</li></ul><p>我们可以创建自定义注解，为了创建自定义注解java还提供了4种源注解，专门负责注解的创建</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><h5 id="Target-：表示该注解可以用于什么地方，可能的ElementType参数有"><a href="#Target-：表示该注解可以用于什么地方，可能的ElementType参数有" class="headerlink" title="@Target ：表示该注解可以用于什么地方，可能的ElementType参数有"></a>@Target ：表示该注解可以用于什么地方，可能的ElementType参数有</h5><ul><li>CONSTRUCTOR：构造器的声明。</li><li>FIELD：域声明（包括enum实例）。</li><li>LOCAL_VARIABLE：局部变量声明。</li><li>METHOD：方法声明。</li><li>PACKAGE：包声明。</li><li>PARAMETER：参数声明。</li><li>TYPE：类、接口（包括注解类型）或enum声明。</li></ul><h5 id="Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括"><a href="#Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括" class="headerlink" title="@Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括"></a>@Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括</h5><ul><li>SOURCE：注解将被编译器丢弃。</li><li>CLASS：注解在class文件中可用，但会被VM丢弃。</li><li>RUNTIME：VM将在运行期间保留注解，因此可以通过反射机制读取注解的信息。</li></ul><h5 id="Document-：将注解包含在Javadoc中"><a href="#Document-：将注解包含在Javadoc中" class="headerlink" title="@Document ：将注解包含在Javadoc中"></a>@Document ：将注解包含在Javadoc中</h5><h5 id="Inherited-：-允许子类继承父类中的注解"><a href="#Inherited-：-允许子类继承父类中的注解" class="headerlink" title="@Inherited ： 允许子类继承父类中的注解"></a>@Inherited ： 允许子类继承父类中的注解</h5><h5 id="下面我创建一个名称为-Description的自定义注解"><a href="#下面我创建一个名称为-Description的自定义注解" class="headerlink" title="下面我创建一个名称为@Description的自定义注解"></a>下面我创建一个名称为@Description的自定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> maxu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 这里使用@interface 关键字来定义注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是声明一个成员变量，并且要求无参数，无抛出异常</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function">String <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">author</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用 default 关键字来给成员指定默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 12</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们定义成员只是使用了String和int 类型，其实注解中成员变量的合法类型可以包括原始的基本类型，String，Class，Annotion,Enumeration.</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    如果注解只有一个成员变量的时候，成员的名称必须取名为value(),在使用的时候我们可以忽略成员名称，和赋值号（=）。</p><p>​    注解类可以没有成员变量，没有成员变量的注解称为标识注解。</p><h5 id="使用上面我们定义的-Description注解"><a href="#使用上面我们定义的-Description注解" class="headerlink" title="使用上面我们定义的@Description注解"></a>使用上面我们定义的@Description注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// age属性可以不用赋值，因为我们定义的时候提供了默认值</span></span><br><span class="line"><span class="meta">@Description</span>(desc = <span class="string">"很可爱"</span>, author = <span class="string">"1"</span>, age = <span class="number">14</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"使用注解"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h3><p>​    通过反射获取类、函数或者成员上运行时注解信息，从而实现动态控制程序运行的逻辑。</p><p>我们可以尝试来解析我们刚刚定义的@Description注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 解析类上的注解</span></span><br><span class="line">    <span class="comment">// 首先我们应该加载我们标记注解的类</span></span><br><span class="line">    Class c = Class.forName(<span class="string">"类路径"</span>);</span><br><span class="line">    <span class="comment">// 判断当前类上面是否添加上@Description注解</span></span><br><span class="line">    <span class="keyword">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class="line">    <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">        <span class="comment">// 拿到注解的实例</span></span><br><span class="line">        Description description = (Description) c.getAnnotation(Description.class);</span><br><span class="line">        System.out.println(description.age());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析方法上的注解</span></span><br><span class="line">    <span class="comment">// 首先遍历所有的方法</span></span><br><span class="line">    Method[] methods = c.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 判断是否有该注解</span></span><br><span class="line">        <span class="keyword">boolean</span> sure = method.isAnnotationPresent(Description.class);</span><br><span class="line">        <span class="keyword">if</span> (sure) &#123;</span><br><span class="line">            Description annotation = method.getAnnotation(Description.class);</span><br><span class="line">            System.out.println(annotation.age());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二中解析方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 获取所有的注解</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="comment">// 判断注解的类型</span></span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Description) &#123;</span><br><span class="line">                Description description = (Description) annotation;</span><br><span class="line">                System.out.println(description.age());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      java注解的使用
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>GC</title>
    <link href="http://yoursite.com/2018/09/17/gc/"/>
    <id>http://yoursite.com/2018/09/17/gc/</id>
    <published>2018-09-16T16:47:01.000Z</published>
    <updated>2019-08-11T05:25:14.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p>对象没有被其他对象所引用的时候，就可以被垃圾收集</p><h4 id="判断对象是否被引用的算法"><a href="#判断对象是否被引用的算法" class="headerlink" title="判断对象是否被引用的算法"></a>判断对象是否被引用的算法</h4><p>引用计数算法：</p><ul><li>判断对象的引用数量来决定对象是否可以被回收</li><li>每个对象实例都有一个引用计数器，被引用则+1,完成引用则-1</li><li>任何引用计数为0的对象实例可以被当作垃圾收集</li></ul><p>优点：</p><ul><li>执行效率高，程序执行受影响小</li></ul><p>缺点：</p><ul><li>无法检测出循环引用的情况，导致内存泄漏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyObject childNode;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">    MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">    </span><br><span class="line">    object1.childNode = object2;</span><br><span class="line">    object2.childNode = object1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过判断对象的引用链是否可达来决定对象是否可以被回收</p><h5 id="可以作为GC-Root对象"><a href="#可以作为GC-Root对象" class="headerlink" title="可以作为GC Root对象"></a>可以作为GC Root对象</h5><ul><li>虚拟机栈中引用的对象</li><li>方法区中的常量引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>本地方法栈中引用的对象</li><li>活跃线程的引用对象</li></ul><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551597118264&amp;di=9f4b22615645df3c7069d1cb5cb8e54b&amp;imgtype=0&amp;src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F9463862-4e25919d342883f8.png" alt="img"></p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>永久代主要回收无用的常量和无用的类</p><p>判断一个常量是否无用，只需要判断时候还存在引用</p><p>判断一个类是否是无用的类，需要判断该类的所有实例已经被回收，类加载器被回收，类对象没有被任何地方引用，无法在任何地方通过反射访问该类的方法。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h5 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h5><p>标记：从根集合进行扫描，对存活的对象进行标记</p><p>清除：对堆内存从头到尾进行线性的遍历，回收不可达的对象内存</p><p><img src="/2018/09/17/gc/images/1551588132324.png" alt="1551588132324"></p><p>缺点：</p><ul><li>碎片化，如果在以后的分配过程中不满足，又要触发一次垃圾收集的动作</li><li>标记和清除的效率都不高</li></ul><h5 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h5><ul><li>分为对象面和空闲面</li><li>对象在对象面上创建</li><li>存活的对象被从对象面复制到空闲面</li><li>将对象面所有对象内存清除</li></ul><p>优点</p><ul><li>解决碎片化</li><li>顺序分配内存，简单高效</li><li>适用于对象村活低的场景</li><li>适用年轻代的收集，如果年轻代没有足够的内存，使用老年代来进行担保</li></ul><p>缺点</p><ul><li>可用内存缩小</li></ul><p><img src="/2018/09/17/gc/images/1551589760984.png" alt="1551589760984"></p><h5 id="标记-整理算法（Compacting）"><a href="#标记-整理算法（Compacting）" class="headerlink" title="标记-整理算法（Compacting）"></a>标记-整理算法（Compacting）</h5><ul><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。</li></ul><p>优点：</p><ul><li>避免内存的不连续，解决碎片化</li><li>不用设置两块内存互换，较少了内存空间的浪费</li><li>适用于存活率高的场景</li></ul><p><img src="/2018/09/17/gc/images/1551589483095.png" alt="1551589483095"></p><h5 id="分代收集算法（Generational-Collector）"><a href="#分代收集算法（Generational-Collector）" class="headerlink" title="分代收集算法（Generational Collector）"></a>分代收集算法（Generational Collector）</h5><ul><li>垃圾回收算法的组合拳</li><li>一般把堆分为新生代和老年代</li><li>新生代采用复制算法，老年代采用标记整理算法 </li><li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li><li>目的：提高JVM的回收率</li></ul><p><img src="/2018/09/17/gc/images/1551590019486.png" alt="1551590019486"></p><h5 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h5><ul><li>Minor GC <ul><li>复制算法</li><li>发生在年轻代</li><li>发生频繁</li></ul></li><li>Full GC<ul><li>标记清除、标记整理</li><li>年轻代和老年代</li><li>发生率低</li></ul></li></ul><h5 id="年轻代-尽可能快速的收集掉那些生命周期短的对象"><a href="#年轻代-尽可能快速的收集掉那些生命周期短的对象" class="headerlink" title="年轻代: 尽可能快速的收集掉那些生命周期短的对象"></a>年轻代: 尽可能快速的收集掉那些生命周期短的对象</h5><p>Eden区</p><p>两个Survivor区</p><p><img src="/2018/09/17/gc/images/1551590595600.png" alt="1551590595600"></p><p>经历一次Minor次数依然存活的对象</p><p>Survivor区中存放不下的对象</p><p>新生成的大对象</p><h5 id="常用的调优参数"><a href="#常用的调优参数" class="headerlink" title="常用的调优参数"></a>常用的调优参数</h5><p>-XX: SurvivorRation :Eden和Survivor的比值，默认是8：1</p><p>-XX:NewRation:老年代和年轻代内存大小的比例</p><p>-XX:MaxTenuringThreshold:对象从年轻代晋升到老年代经过GC次数的最大阈值</p><p>老年代：存放生命周期较长的对象</p><h5 id="触发Full-GC的条件"><a href="#触发Full-GC的条件" class="headerlink" title="触发Full GC的条件?"></a>触发Full GC的条件?</h5><ul><li>老年代空间不足</li><li>永久代空间不足（JDK7以前）</li><li>Minor GC 晋升到老年代的平均大小大于老年代的剩余空间</li><li>CMS GC时出现promotion failed,concurrent mode failure</li><li>调用System.gc()</li><li>使用RMI来进行RPC或管理的JDK应用，每一小时触发一次Full GC</li></ul><h3 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h3><ul><li>JVM由于 要执行GC而停止了应用程序的执行</li><li>任何一种GC算法中都会发生</li><li>多数GC的优化通过减少Stop-The-World发生的时间来提高程序性能</li></ul><h3 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h3><ul><li>分析过程中对象引用关系不会变化的点    </li><li>产生Safepoint的地方：方法调用；循环跳转；异常跳转等</li><li>安全点要适中</li></ul><h5 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h5><ul><li>Server</li><li>Client</li></ul><h5 id="Serial收集器（-XX-UseSerialGC复制算法）"><a href="#Serial收集器（-XX-UseSerialGC复制算法）" class="headerlink" title="Serial收集器（-XX:+UseSerialGC复制算法）"></a>Serial收集器（-XX:+UseSerialGC复制算法）</h5><ul><li>单线程收集，进行垃圾收集时，必须暂停所有的工作线程。</li><li>简单高效，Client模式下默认的年轻代收集器。</li></ul><p><img src="/2018/09/17/gc/images/1551593597605.png" alt="1551593597605"></p><h5 id="ParNew收集器（-XX-UseParNewGC-复制算法）"><a href="#ParNew收集器（-XX-UseParNewGC-复制算法）" class="headerlink" title="ParNew收集器（-XX:+UseParNewGC,复制算法）"></a>ParNew收集器（-XX:+UseParNewGC,复制算法）</h5><ul><li>多线程收集，其余行为，特点和Serial收集器一样</li><li>单核执行效率不如Serial，在多核下执行才有优势</li></ul><p><img src="/2018/09/17/gc/images/1551593919763.png" alt="1551593919763"></p><h5 id="Parallel-Scavenge收集器（-XX：-UseParallelGC，复制算法）"><a href="#Parallel-Scavenge收集器（-XX：-UseParallelGC，复制算法）" class="headerlink" title="Parallel Scavenge收集器（-XX：+UseParallelGC，复制算法）"></a>Parallel Scavenge收集器（-XX：+UseParallelGC，复制算法）</h5><ul><li>吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</li><li>多线程，比起关注用户停顿时间，更关注系统的吞吐量，适合后台运算而不需要太多交互的任务</li><li>在多核执行下有优势，Server模式下默认的年轻代收集器</li><li>-XX:UseAdaptiveSizePolicy :调优</li></ul><p>老年代收集器：</p><h5 id="Serial-Old收集器（-XX：-UseSerialOldGC-标记-整理算法）"><a href="#Serial-Old收集器（-XX：-UseSerialOldGC-标记-整理算法）" class="headerlink" title="Serial Old收集器（-XX：+UseSerialOldGC,标记-整理算法）"></a>Serial Old收集器（-XX：+UseSerialOldGC,标记-整理算法）</h5><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的老年代收集器</li></ul><p><img src="/2018/09/17/gc/images/1551598747027.png" alt="1551598747027"></p><h5 id="Parallel-Old收集器（-XX-UseParallelOldGC-标记-整理算法）"><a href="#Parallel-Old收集器（-XX-UseParallelOldGC-标记-整理算法）" class="headerlink" title="Parallel Old收集器（-XX:+UseParallelOldGC 标记-整理算法）"></a>Parallel Old收集器（-XX:+UseParallelOldGC 标记-整理算法）</h5><ul><li>多线程，吞吐量</li></ul><p><img src="/2018/09/17/gc/images/1551598843583.png" alt="1551598843583"></p><h5 id="CMS收集器（-XX-UseConcMarkSweepGC，标记-清除算法）"><a href="#CMS收集器（-XX-UseConcMarkSweepGC，标记-清除算法）" class="headerlink" title="CMS收集器（-XX:+UseConcMarkSweepGC，标记-清除算法）"></a>CMS收集器（-XX:+UseConcMarkSweepGC，标记-清除算法）</h5><ul><li>初始化标记：stop-the-wold</li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行并发标记阶段从年轻代，晋升到老年代的对象</li><li>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置CMS收集器的数据结构</li></ul><p>CMS收集器的内存回收过程是和用户线程一起并发执行的。减少了用户的停顿时间</p><p>缺点：</p><ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>产生碎片化空间</li></ul><h5 id="Garbage-First收集器的特点"><a href="#Garbage-First收集器的特点" class="headerlink" title="Garbage First收集器的特点"></a>Garbage First收集器的特点</h5><p>将堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的物理的，他们都是一部分Region的集合。</p><ul><li>并发和并行</li><li>分代收集</li><li>空间整合，从整体上看是基于标记-整理算法，但是从两个Region之间来看是基于复制算法实现的，无论是那种算法东不会在运行期间产生内存碎片。</li><li>可预测的停顿</li></ul><p>将整个Java堆内存划分成多个大小相等的Region</p><p>年轻代和老年代不再物理隔离</p><h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><p>Object的finalize()方法的作用是否与C++的析构函数作用相同？</p><ul><li>与C++的析构函数不同，析构函数调用确定，而它是不同的</li><li>将为被引用的对象放置于F-Queue队列</li><li>finalize()方法执行之后可能会被终止</li><li>给予对象最后一次逃脱的机会</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.gc();<span class="comment">// 触发finalize()方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Java中的强引用，软引用，弱引用，虚引用？</p><p>强引用：</p><ul><li><p>最普遍的引用 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object  = <span class="keyword">new</span> Object()</span><br></pre></td></tr></table></figure></li><li><p>当内存不够抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</p></li><li><p>通过将对象设置为null来弱化引用，使其被回收</p></li></ul><p>软引用：</p><ul><li><p>对象处在游离但非必须的状态</p></li><li><p>只有当内存不足的时候，GC会回收该引用的对象内存</p></li><li><p>可以用来实现高速缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> Stirng(<span class="string">"abc"</span>); <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> SoftReferece&lt;String&gt;(str);<span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure></li></ul><p>弱引用：</p><ul><li>非必需的对象，比软引用更弱一些</li><li>GC时被回收</li><li>被回收的概率也不大，因为GC线程优先级比较低</li><li>使用与引用偶尔被使用且不影响垃圾收集的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> Stirng(<span class="string">"abc"</span>); <span class="comment">// 强引用</span></span><br><span class="line">WeakReference&lt;String&gt; ref = <span class="keyword">new</span> WeakReferece&lt;String&gt;(str);<span class="comment">// 弱引用</span></span><br></pre></td></tr></table></figure><p>虚引用：</p><ul><li>不会决定对象的生命周期</li><li>任何时候都可能被垃圾收集器回收</li><li>跟踪对象被垃圾收集器回收的活动，起哨兵的作用</li><li>必须和引用该队列ReferenceQueue联合使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> Stirng(<span class="string">"abc"</span>); <span class="comment">// 强引用</span></span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference ref = <span class="keyword">new</span> PhantomReference(str,queue);<span class="comment">// 虚引用</span></span><br></pre></td></tr></table></figure><h3 id="对象第二次拯救"><a href="#对象第二次拯救" class="headerlink" title="对象第二次拯救"></a>对象第二次拯救</h3><p>对象真正的死亡至少需要经历两次标记的过程，如果对象在进行可达性分析算法之后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，对象是否有必要执行finalize方法，如果对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过一次，则没有必要执行finalize方法。当对象被判定为执行finalize方法的时候，将对象放置在一个F-Queue队列中，并稍后有Java虚拟机创建一个Finazlizer线程去触发这个方法。如果对象要在finalize（）成功拯救自己，只需要重新或者对象引用链上任何一个对象关联即可。</p>]]></content>
    
    <summary type="html">
    
      GC的相关介绍
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/2018/08/13/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/13/Java基础/</id>
    <published>2018-08-12T16:47:01.000Z</published>
    <updated>2019-08-12T09:18:09.182Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/08/13/Java基础/overview.png" alt="overview"></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li><p>创建 Enum 时，编译器会为你生成一个相关的类，这个类继承自<code>Java.lang.Enum</code></p></li><li><p>enum会自动创建toString()和name()方法，以便可以方便的显示某个enum实例的名字；</p></li><li>enum还会创建ordinal()方法，用来表示某个特定enum常量的声明顺序，从0开始；</li><li>enum创建了static values()方法，用来按照enum常量的声明顺序，产生这些常量值构成的数组。</li><li>valueOf()是在Enum中定义的static方法，它根据给定的名字返回相应的enum实例，如果不存在给你名字的实例，将会抛出异常。</li><li>可以使用==来比较enum实例，编译器自动为你提供了equals和hashcode方法。</li><li>Enum类实现了 Comparable 接口，所以它具有compareTo()方法。</li></ul><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>1、枚举的直接父类是java.lang.Enum，但是不能显示的继承Enum</li><li>2、枚举就相当于一个类，可以定义构造方法、成员变量、普通方法和抽象方法</li><li>3、默认私有的构造方法，即使不写访问权限也是private。（假构造器，底层没有无参数的构造器）</li><li>4、每个实例分别用于一个全局常量表示，枚举类型的对象是固定的，实例个数有限，不能使用new关键字。</li><li>5、枚举实例必须位于枚举中最开始部分，枚举实例列表的后面要有分号与其他成员相分隔</li><li>6、枚举实例后有花括号时，该实例是枚举的匿名内部类对象</li><li>7、枚举类可以有构造器，但必须是private的，它默认的也是private的。</li><li>8、枚举类也可以有抽象方法，但是枚举项必须重写该方法</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </span><br><span class="line">  RED, GREEN, BLANK, YELLOW  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JDK1.6之前的<span class="keyword">switch</span>语句只支持<span class="keyword">int</span>,<span class="keyword">char</span>,<span class="keyword">enum</span>类型，使用枚举，能让我们的代码可读性更强。</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Signal &#123;  </span><br><span class="line">    GREEN, YELLOW, RED  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;  </span><br><span class="line">    Signal color = Signal.RED;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (color) &#123;  </span><br><span class="line">        <span class="keyword">case</span> RED:  </span><br><span class="line">            color = Signal.GREEN;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> YELLOW:  </span><br><span class="line">            color = Signal.RED;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> GREEN:  </span><br><span class="line">            color = Signal.YELLOW;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </span><br><span class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </span><br><span class="line">    <span class="comment">// 成员变量  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </span><br><span class="line">    <span class="comment">// 构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 普通方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c.getIndex() == index) &#123;  </span><br><span class="line">                <span class="keyword">return</span> c.name;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// get set 方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖枚举的方法"><a href="#覆盖枚举的方法" class="headerlink" title="覆盖枚举的方法"></a>覆盖枚举的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </span><br><span class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </span><br><span class="line">    <span class="comment">// 成员变量  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </span><br><span class="line">    <span class="comment">// 构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//覆盖方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index+<span class="string">"_"</span>+<span class="keyword">this</span>.name;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>所有的枚举都继承自<code>java.lang.Enum</code>类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Behaviour</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color implements Behaviour&#123;  </span><br><span class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </span><br><span class="line">    <span class="comment">// 成员变量  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </span><br><span class="line">    <span class="comment">// 构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//接口方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//接口方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="keyword">this</span>.index+<span class="string">":"</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是定义在另一个类中的类</p><h3 id="为什么要使用内部类呢？"><a href="#为什么要使用内部类呢？" class="headerlink" title="为什么要使用内部类呢？"></a>为什么要使用内部类呢？</h3><ol><li>内部类方法可以访问该类定义所在的作用域中的数据，包含私有的数据</li><li>内部类可以对同一个包中的其它类隐藏起来</li><li>当想要定义一个回调函数而且不想编写大量代码的时候，使用匿名内部类比较便捷。</li></ol><h3 id="内部类访问的局部变量必须用final修饰-为什么"><a href="#内部类访问的局部变量必须用final修饰-为什么" class="headerlink" title="内部类访问的局部变量必须用final修饰,为什么?"></a>内部类访问的局部变量必须用final修饰,为什么?</h3><p>​    因为当调用内部类方法时,在方法体中访问的局部变量如果没有用<code>final</code>修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失，如果还想用这个局部变量,就没有了,如果用<code>final</code>修饰，局部变量会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li><p>内部类中的静态域必须是final修饰的，原因很简单，我们希望静态域只有一个实例，不过对于外部对象，会分别有一个内部实例。如果静态域不是final修饰它可能使不唯一的。</p></li><li><p>编译器将会把内部类翻译成用 $ (美元符号）分隔外部类名与内部类名的常规类文件， 而虚拟机则对此一无所知</p></li><li><p>局部内部类：不能用public或private修饰，它的作用域被限定在这个局部类的块中。</p></li><li>在内部类中有一个隐式的外部类的引用。这个引用在内部类中是不可见的。</li></ul><p>当变量的编译时类型和运行时类型不同时，通过该变量访问它引用的对象的势力变量的时，该实例变量的值由声明改变量的类型决定的。但通过该变量调用它引用的对象的实例方法时，该方法行为将由他实际引用的对象来决定。</p><p><img src="/2018/08/13/Java基础/1549014708591.png" alt="1549014708591"></p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>如果自下而上在类的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。</li><li>祖先类更加通用，人们只是将它作为其它类的基类，而不是作为想使用特定的实例类。</li><li>用关键字abstract可以标识一个抽象类：除了抽象方法以外，抽象类可以包含具体的数据和具体的方法。</li><li>抽象方法是没有方法体的。</li><li>抽象类不能够被实例化。如果将一个类声明为abstract，就不能创建这个类的对象。</li><li>我们可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>一个对象变量，可以指示多种实际的类型的现象被称为多态，在运行的时候，能够自动的选择调用哪个方法的现象被称为动态绑定。</li><li>如果不想让一个方法具有虚拟特征可以将方法设置为final</li><li>不能将一个父类的引用赋值给子类的变量。</li><li>在Java中，子类的数组可以转化为父类的数组的引用，而不用采用强制类型转换。</li></ul><h2 id="fianl类和方法"><a href="#fianl类和方法" class="headerlink" title="fianl类和方法"></a>fianl类和方法</h2><ul><li>不允许扩展的类被称为final类。</li><li>被final修饰的方法不能覆盖这个方法</li><li>域也可以被声明为 final。对于 final 域来说，构造对象之后就不允许改变它们的值了。不过， 如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域</li></ul><h2 id="equals方法与-hashCode方法"><a href="#equals方法与-hashCode方法" class="headerlink" title="equals方法与 hashCode方法"></a>equals方法与 hashCode方法</h2><h3 id="equals"><a href="#equals" class="headerlink" title="equals:"></a>equals:</h3><ul><li>用于检测一个对象是否等于另一个对象。</li><li>在Object类中，这个方法判断对象是否具有相同的引用，如果这两个对象具有相同的</li><li>引用就代表这两个对象是相等的。</li><li>为了防备两属性可能为null的情况，我们需要使用Object.equals方法：如果两个参数都是null,Objdect.equals(a,b)将返回true，如果其中一个参数为null则，则返回false，如果两个参数都不为null，调用a.equals(b)</li></ul><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性</li><li>对任意非空引用x, x.equals(null),都返回false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == other)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 检测是否是引用同一个对象</span></span><br><span class="line"><span class="keyword">if</span>(other == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> fasle; <span class="comment">// 检测other是否为null</span></span><br><span class="line"><span class="keyword">if</span>(getClass() != other.getClass()) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!(other instaceof ClassName))</span><br><span class="line">    <span class="keyword">return</span> fasle; <span class="comment">// 将othre转换为相应的类类型变量</span></span><br><span class="line">ClassName other = (ClassName) othreName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始比较域，使用 == 比较基本类型域，使用equal比较对象域</span></span><br><span class="line"><span class="comment">// 如果所有的都匹配返回true,否则返回false</span></span><br></pre></td></tr></table></figure><h4 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode:"></a>HashCode:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ok"</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">System.out.println(s.hashCode()+ <span class="string">" "</span> + sb.hashCode());</span><br><span class="line">String t = <span class="keyword">new</span> String(<span class="string">"ok"</span>);</span><br><span class="line">StringBuilder tb = <span class="keyword">new</span> StringBuilder(t);</span><br><span class="line">System.out.println(t.hashCode() + <span class="string">" "</span> + tb.hashCode());</span><br></pre></td></tr></table></figure><table><thead><tr><th>对象</th><th>hasCode</th></tr></thead><tbody><tr><td>s</td><td>3548</td></tr><tr><td>sb</td><td>460141958</td></tr><tr><td>t</td><td>3548</td></tr><tr><td>tb</td><td>1163157884</td></tr></tbody></table><p>字符串 s 和 t 拥有相同的散列码，是因为字符串的散列码是由内容导出的，而字符串缓冲sb与tb却有着不同的散列码，这是因为在StringBuilder类中没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址。</p><p>如果重新定义了equals方法，就必须重新定义hashCode方法，以便用户可以将对象方便的插入到散列列表中，hashCode应该返回一个整形数值，并合理地组合实例域的散列码，以便用户能够让各个不同的对象产生散列码更加均匀。</p><p>equals与hashCode的定义必须一致，如果x.equals(y),那么x.hashCode()就必须与y.hashCode()具有相同的值。比如，如果用定义的Employee.equals比较雇员的ID，那么hashCode方法就需要散列ID,而不是雇员的姓名或者存储地址。</p><h2 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h2><p><img src="/2018/08/13/Java基础/1553175374905.png" alt></p><h3 id="概念角度解析Java的异常处理机制"><a href="#概念角度解析Java的异常处理机制" class="headerlink" title="概念角度解析Java的异常处理机制"></a>概念角度解析Java的异常处理机制</h3><ul><li>Error：程序无法处理的系统错误，编译器不做检查</li><li><p>Exception:程序可以处理的异常，捕获后可能恢复</p><p>总结：前者是程序无法处理的异常，后者是可以处理的异常 </p></li></ul><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><h4 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h4><ul><li>NullPointerException 空指针异常</li><li>ClassCastException 类型强制转换异常</li><li>IllegalArgumentException 传递非法参数异常</li><li>IndexOutOfBoundsException 下标越界异常</li><li>NumberFormatException 数字格式异常</li></ul><h4 id="非RuntimeException"><a href="#非RuntimeException" class="headerlink" title="非RuntimeException"></a>非RuntimeException</h4><ul><li>ClassNotFoundException 找不到指定Class异常</li><li>IOException IO操作异常</li></ul><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ul><li>NoClassDefFoundError 找不到class定义的异常</li><li>StackOverflowerError 深递归导致栈被耗尽而抛出异常</li><li>OutOfMemoryError 内存溢出异常</li></ul><h3 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h3><p>抛出异常：创建异常对象，交由运行时系统处理</p><p>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</p><h3 id="Java异常处理的原则"><a href="#Java异常处理的原则" class="headerlink" title="Java异常处理的原则"></a>Java异常处理的原则</h3><ul><li>具体明确：抛出的异常应该能够通过类名称和message准确的说明异常的类型和产生异常的原因</li><li>提早抛出：应该尽可能的早发现并抛出异常，便于精确定位</li><li>延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常</li></ul><h3 id="Java异常处理消耗性能的地方"><a href="#Java异常处理消耗性能的地方" class="headerlink" title="Java异常处理消耗性能的地方"></a>Java异常处理消耗性能的地方</h3><ul><li>try-catch块影响JVM的优化</li><li>异常对象实例需要保存栈的快照等信息，消耗性能</li></ul>]]></content>
    
    <summary type="html">
    
      对学习的知识进行回顾和总结
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Liunx</title>
    <link href="http://yoursite.com/2018/07/10/Linux/"/>
    <id>http://yoursite.com/2018/07/10/Linux/</id>
    <published>2018-07-10T08:04:49.000Z</published>
    <updated>2019-08-11T05:25:14.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令学习"><a href="#命令学习" class="headerlink" title="命令学习"></a>命令学习</h1><ul><li>返回上一次所在的目录：cd - </li><li>查看环境变量：echo $PATH</li><li>设置环境变量：PATH=””</li><li>设置可执行权限：chmod +x 文件名称</li><li>查看文件自身信息：ls -d</li><li>递归产看文件信息：ls -R</li><li>复制 cp[选项] /path1/文件夹1 /path2/文件夹2<br>如果不存在这个文件夹2或者不存在,则把/path1/文件夹1拷贝到文件path2下并且重命名为文件夹2</li><li>cp -a -r -f -u -p -d</li><li>-a 可以拷贝文件夹</li><li>-f 强制</li><li>-r 递归</li><li>-d 拷贝链接</li><li>-p 文件信息</li><li>剪切：mv<br>有重命名的作用 mv a b 将a重命名为b</li><li>basename 得到文件名</li><li>dirname 得到文件所在的路径名</li><li>产看文档的内容 cat tac head nl tail more less 只能查看文本文件</li><li>cat：只适合查看一些小文件<br>-n 加上文档的行数</li><li>tac: 倒置显示文件</li><li>nl：跟cat -n 作用相同，不现实空白行<br>-b：显示空白行</li><li>more：分屏查看文件内容，只能往后翻不能往前翻</li><li>less:查看文件</li><li>head：可以查看文件的前几行<br>hand  行数 文件名</li><li>tail:查看文件的尾几行</li><li>tail -f 可以时时监控文件的变化。</li><li>od -t c ：查看二进制文件</li><li>touch 文件名称 ：如果文件不存在则创建一个文件，如果文件存在则跟新文件创建的时间为当前时间。<br>-文件默认权限：umask<br>当创建目录的时候，权限就是减去默认umask的值<br>当创建文件的时候，权限不等于直接减去umask的值</li><li>查看隐藏权限：lsattr</li><li>添加隐藏文件：chattr<br>+a 只能添加，不能删除<br>+i 无法修改</li><li>修改文件所有者 chown 用户 文件名称</li><li>修改文件所在的组  chgrp 组名 文件名称</li><li>查找命令所在的路径：whereis -b -m 命令</li></ul><h1 id="文件-磁盘管理"><a href="#文件-磁盘管理" class="headerlink" title="文件-磁盘管理"></a>文件-磁盘管理</h1><h2 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h2><p>  shutdown -h 10 十分钟后关闭计算机<br>  sync 将缓存的东西写入硬盘当中去<br>  init 切换运行级别<br>  runlevel 查看当前运行级别<br>  reboot -f 立即重启</p><h2 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录: mkdir"></a>创建目录: mkdir</h2><p>通过mkdir命令可以创建⼀个新的⽬录。参数-p可递归创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。</p><h2 id="显示文件目录-tree"><a href="#显示文件目录-tree" class="headerlink" title="显示文件目录 tree"></a>显示文件目录 tree</h2><p>按照树状结构显示文件目录</p><h2 id="删除目录-rmdir"><a href="#删除目录-rmdir" class="headerlink" title="删除目录: rmdir"></a>删除目录: rmdir</h2><p>可以使用rmdir删除文件目录，但是你必须要离开当前目录，并且目录为空。否则删除失败。</p><h2 id="删除文件-rm"><a href="#删除文件-rm" class="headerlink" title="删除文件: rm"></a>删除文件: rm</h2><p>可通过rm删除⽂件或⽬录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文<br>件误删，可以在rm后使用-i参数以逐个确认要删除的文件。</p><h2 id="建立链接文件-in"><a href="#建立链接文件-in" class="headerlink" title="建立链接文件: in"></a>建立链接文件: in</h2><p>Linux链接文件类似于Windows下的快捷方式。<br>链接文件分为软链接和硬链接。<br>软链接：软链接不占用磁盘空间，源文件删除则软链接失效。<br>硬链接：硬链接只能链接普通文件，不能链接目录。</p><p>使用格式:<br>    ln 源文件 链接文件<br>    ln -s 源文件 链接文件<br>如果 没有-s 选项代表建立一个硬链接文件，两个文件占用相同存储的硬盘空间，即使删除<br>了源文件，链接文件还是存在，所以-s选项是更常的的形式。<br>注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。</p><h2 id="输出文件内容或者合并文件内容-cat"><a href="#输出文件内容或者合并文件内容-cat" class="headerlink" title="输出文件内容或者合并文件内容 cat"></a>输出文件内容或者合并文件内容 cat</h2><p>cat test.txt 查看当前路径下的文件内容<br>cat test.txt test1.txt &gt; heihei.text 将两个文件的内容重定向到heihei.text</p><blockquote><p>先清空后添加 &gt;&gt; 不会覆盖，直接在尾部添加</p></blockquote><h2 id="cp-拷贝文件"><a href="#cp-拷贝文件" class="headerlink" title="cp: 拷贝文件"></a>cp: 拷贝文件</h2><p>cp test/haha test3 -ivr 将目录haha复制到test3文件中</p><h2 id="移动文件-mv"><a href="#移动文件-mv" class="headerlink" title="移动文件: mv"></a>移动文件: mv</h2><p>  用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。</p><h2 id="归档管理-tar"><a href="#归档管理-tar" class="headerlink" title="归档管理: tar"></a>归档管理: tar</h2><p>计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系<br>列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。<br>tar使用格式 tar [参数] 打包文件名 文件</p><h2 id="文件压缩解压-gizp"><a href="#文件压缩解压-gizp" class="headerlink" title="文件压缩解压: gizp"></a>文件压缩解压: gizp</h2><p>tar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压<br>缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。<br>gzip [选项] 被压缩文件<br>-d 解压<br>-r 压缩所有子目录</p><hr><p>如果要使用tar来压缩文件可以增加参数z来实现<br>tar -cvzf test.tar.gz * 当前路径下所有的文件以及文件夹打包并压缩到test.tar.gz文件中<br>解压用法： tar zxvf 压缩包包名<br>tar zxvf test.tar.gz 解压到当前路径下<br>tar zxvf test.tar.gz -C dongge/ 解压到指定路径下</p><h2 id="查看命令位置-which"><a href="#查看命令位置-which" class="headerlink" title="查看命令位置: which"></a>查看命令位置: which</h2><p>which ls</p><h1 id="Linux命令-用户、权限管理"><a href="#Linux命令-用户、权限管理" class="headerlink" title="Linux命令-用户、权限管理"></a>Linux命令-用户、权限管理</h1><h2 id="查看当前用户-whoami"><a href="#查看当前用户-whoami" class="headerlink" title="查看当前用户: whoami"></a>查看当前用户: whoami</h2><h2 id="who"><a href="#who" class="headerlink" title="who"></a>who</h2><p>who命令用于查看当前所有登录系统的用户信息。</p><h2 id="设置文件权限-chmod"><a href="#设置文件权限-chmod" class="headerlink" title="设置文件权限: chmod"></a>设置文件权限: chmod</h2><p>字母法：chmod u/g/o/a +/-/= rwx 文件<br>数字法：chmod 777 文件<br>w = 2<br>r = 4<br>x = 1<br>- = 0</p><h2 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者: chown"></a>修改文件所有者: chown</h2><p>sudo chown 用户 文件</p><h2 id="修改文件所属组：chgrp"><a href="#修改文件所属组：chgrp" class="headerlink" title="修改文件所属组：chgrp"></a>修改文件所属组：chgrp</h2><p>sudo chgrp 组名 文件</p><h1 id="Linux系统管理"><a href="#Linux系统管理" class="headerlink" title="Linux系统管理"></a>Linux系统管理</h1><h2 id="查看进程信息：ps"><a href="#查看进程信息：ps" class="headerlink" title="查看进程信息：ps"></a>查看进程信息：ps</h2><h2 id="杀死进程kill"><a href="#杀死进程kill" class="headerlink" title="杀死进程kill"></a>杀死进程kill</h2><p>需要配合ps使用 如果要强制结束可以使用参数-9</p><p>ubuntu如何切换到root用户</p><p>默认安装完成之后并不知道root用户的密码，那么如何应用root权限呢？<br>(1)sudo 命令<br>这样输入当前管理员用户密码就可以得到超级用户的权限。但默认的情况下5分钟root权限就失效了。<br>(2)sudo -i<br>通过这种方法输入当前管理员用户的密码就可以进到root用户。<br>(3)如果想一直使用root权限，要通过su切换到root用户。<br>那我们首先要重设置root用户的密码：<br>sudo passwd root<br>这样就可以设置root用户的密码了。</p><p>su “用户名” 或者 exit回到用户权限</p><p>之后就可以自由的切换到root用户了<br>su<br>输入root用户的密码即可。</p><h2 id="关于挂载点的理解"><a href="#关于挂载点的理解" class="headerlink" title="关于挂载点的理解"></a>关于挂载点的理解</h2><p>Linux是树型目录结构，与windows的C,D,E盘完全不同，Linux只有一个根目录’/‘，其余各个目录都是基于这个根目录发散，就是树形结构。因此Linux分区跟Windows的C,D,E盘分区完全不同，而是将某个分区挂到一个对应的目录上，例如/home对应一块分区,home目录就是这块分区的挂载点、/boot对应一块分区,boot目录就是这块分区的挂载点、/usr对应一块分区,usr目录就是这块分区的挂载点。你可以形象的理解：一棵大树(根目录/)有很多树枝(目录，挂载点)，每个树枝上都挂着一个箱子(分区，存储空间)。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><table><thead><tr><th>目录名称</th><th>目录内容</th></tr></thead><tbody><tr><td>bin</td><td>保存二进制文件</td></tr><tr><td>boot</td><td>系统的启动文件，包含系统的初始化文件和内核</td></tr><tr><td>dev</td><td>设备文件</td></tr><tr><td>etc</td><td>配置文件</td></tr><tr><td>home</td><td>用户的家目录</td></tr><tr><td>lib</td><td>系统的库文件</td></tr><tr><td>media</td><td>系统的自动挂载点，当你访问U盘的时候实际上访问的是media这个文件夹中的某个子文件夹</td></tr><tr><td>mnt</td><td>挂载点</td></tr><tr><td>opt</td><td>当使用源码包安装软件的时候一般都会把软件安装到opt中去</td></tr><tr><td>proc</td><td>内核中的参数</td></tr><tr><td>root</td><td>系统管理员的家目录</td></tr><tr><td>sbin</td><td>存放的二进制的命令，只有系统管理员可以使用</td></tr><tr><td>usr</td><td>默认安装软件的路径</td></tr><tr><td>tmp</td><td>存放临时文件</td></tr><tr><td>var</td><td>缓存，日志，数据库文件</td></tr></tbody></table><p>假如我下载了100G的电影我放置在那个地方</p><p>可以新建一个文件夹，让分区挂载在这个文件夹上面</p><p><img src="/2018/07/10/Linux/images/timg.jpg" alt="k"></p>]]></content>
    
    <summary type="html">
    
      学习基础的Liunx命令
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
